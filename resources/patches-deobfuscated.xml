<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<mods>
	<minecraftCommon>
		<class id="net.minecraft.world.WorldServer">
			<!-- Fixes an issue where the tickNextTickLists would become out of sync -->
			<synchronize>func_82740_a,scheduleBlockUpdateFromLoad,getPendingBlockUpdates,addBlockEvent</synchronize>
		</class>
		<class id="net.minecraft.world.World">
			<!-- addedEntityList could be added to while looping -->
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">addTileEntity,setBlockTileEntity,addTileEntity</lock>
			<lock field="readLock">getBlockTileEntity</lock>
			<!-- Same list was used by multiple threads -->
			<replaceMethod fromClass="me.nallar.tickthreading.patched.PatchWorld">getEntitiesWithinAABBExcludingEntity</replaceMethod>
			<replaceMethod fromClass="me.nallar.tickthreading.patched.PatchWorld">getCollidingBoundingBoxes</replaceMethod>
			<public>releaseEntitySkin</public>
		</class>
		<class id="net.minecraft.world.chunk.Chunk">
			<!-- The entity list could be accessed from multiple threads, as usual causes problems during iteration -->
			<newField field="entityListReadWriteLock" class="java.util.concurrent.locks.ReentrantReadWriteLock"/>
			<newField field="entityListWriteLock" class="java.util.concurrent.locks.Lock" code="this.entityListReadWriteLock.writeLock();"/>
			<newField field="entityListReadLock" class="java.util.concurrent.locks.Lock" code="this.entityListReadWriteLock.readLock();"/>
			<lock field="entityListWriteLock">onChunkLoad,onChunkUnload,removeEntityAtIndex,addEntity</lock>
			<lock field="entityListReadLock">getEntitiesWithinAABBForEntity,getEntitiesOfTypeWithinAAAB</lock>
		</class>
		<class id="net.minecraft.util.Vec3Pool">
			<!-- This prevents entities in multiple threads using the same Vec3 for collisions. -->
			<synchronize>getVecFromPool</synchronize>
		</class>
		<class id="net.minecraft.util.AxisAlignedBB">
			<!-- Improves performance -->
			<replaceMethod fromClass="me.nallar.tickthreading.patched.PatchAxisAlignedBB">intersectsWith</replaceMethod>
		</class>
		<!--
		<class id="net.minecraft.util.AABBPool">
			Prevent multiple threads accessing the same AABB
			Probably not necessary due to pool, unless MC devs messed up.
			<synchronize>addOrModifyAABBInPool</synchronize>
		</class>
		-->
		<class id="net.minecraft.util.LongHashMap">
			<replace class="me.nallar.tickthreading.patched.LongHashMap"/>
		</class>
		<class id="net.minecraft.entity.player.EntityPlayerMP">
			<!-- Concurrent access during iteration = boom -->
			<newInitializer field="destroyedItemsNetCache" class="me.nallar.tickthreading.collections.ConcurrentLinkedQueueList"/>
		</class>
		<class id="net.minecraft.entity.Entity">
			<newField static="" field="nextEntityID_" class="java.util.concurrent.atomic.AtomicInteger"/>
			<insertAfter field="entityId" code="this.$field = this.nextEntityID_.getAndIncrement();"/>
		</class>
		<class id="net.minecraft.entity.EntityTracker">
			<!-- Yet more comodification exceptions -->
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">addEntityToTracker(Lnet/minecraft/entity/Entity;)V,addEntityToTracker(Lnet/minecraft/entity/Entity;IIZ)V,removeEntityFromAllTrackingPlayers</lock>
			<lock field="readLock">updateTrackedEntities,removeAllTrackingPlayers,func_85172_a</lock>
		</class>
		<class id="net.minecraft.village.VillageCollection">
			<!-- Literally the most useless collection. Locking instead of voiding in case it ever does something useful in future -->
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">addVillagerPosition</lock>
			<lock field="readLock">findNearestVillage,func_82566_a</lock>
		</class>
	</minecraftCommon>
	<factorization>
		<class id="factorization.common.TileEntityWrathLamp">
			<!-- ಠ_ಠ -->
			<synchronize>findLightAirParent</synchronize>
		</class>
	</factorization>
	<liteLoader>
		<class id="com.mumfrey.liteloader.core.HookProfiler">
			<!-- BAAADD, LiteLoader, BAAAD. You don't take a threadsafe profiler and replace it with one which isn't. :/ -->
			<synchronize>a(Ljava/lang/String;)V,b()V</synchronize>
		</class>
	</liteLoader>
	<!-- Might not be needed
	<buildCraftAPI>
		<class id="buildcraft.api.power.PowerProvider">
			<volatile/>
			<synchronize/>
		</class>
	</buildCraftAPI>
	-->
	<buildCraftTransport>
		<class id="buildcraft.transport.TileGenericPipe">
			<synchronize field="facadeBlocks">initialize,blockCreated,getBlockId,getTile,computeConnections</synchronize>
		</class>
	</buildCraftTransport>
</mods>
