<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<mods>
	<tickthreading>
		<class id="me.nallar.tickthreading.minecraft.tickregion.TileEntityTickRegion">
			<lockToSynchronized>doTick</lockToSynchronized>
		</class>
		<class id="me.nallar.tickthreading.minecraft.TickManager">
			<lockToSynchronized>unlock,lock</lockToSynchronized>
		</class>
	</tickthreading>
	<minecraftCommon>
		<class id="net.minecraft.world.SpawnerAnimals" env="forge">
			<addAll fromClass="me.nallar.patched.PatchSpawnerAnimalsForge"/>
		</class>
		<class id="net.minecraft.world.SpawnerAnimals" env="mcpc">
			<synchronize>findChunksForSpawning</synchronize>
		</class>
		<class id="net.minecraft.world.SpawnerAnimals">
			<addAll fromClass="me.nallar.patched.PatchSpawnerAnimals"/>
			<profile>findChunksForSpawning</profile>
		</class>
		<class id=" net.minecraft.world.storage.MapInfo">
			<synchronize>^all^</synchronize>
		</class>
		<class id="net.minecraft.pathfinding.Path">
			<newInitializer field="pathPoints" class="net.minecraft.pathfinding.PathPoint" arraySize="128"/>
		</class>
		<class id="net.minecraft.server.MinecraftServer">
			<addAll fromClass="me.nallar.patched.server.PatchMinecraftServer"/>
			<insertBefore code="{
				if (this.^field:MinecraftServer/serverStopped^) {
					return;
				}
				this.^field:MinecraftServer/serverStopped^ = true;
			}">stopServer
			</insertBefore>
			<synchronize>stopServer</synchronize>
			<public field="mcServer"/>
			<volatile field="serverRunning"/>
			<volatile field="serverIsRunning"/>
			<replaceInitializer field="worlds" class="me.nallar.collections.ListSet"/>
		</class>
		<class id="net.minecraft.server.MinecraftServer" env="mcpc">
			<replaceMethod code="{
					this.server.getScheduler().mainThreadHeartbeat(this.w);

					while (!processQueue.isEmpty()) {
							((Runnable) processQueue.remove()).run();
					}
					}">spigotTLETick
			</replaceMethod>
		</class>
		<class id="net.minecraft.server.MinecraftServer" env="forge">
			<addAll fromClass="me.nallar.patched.server.PatchMinecraftServerForge"/>
		</class>
		<class id="net.minecraft.profiler.Profiler">
			<addAll fromClass="me.nallar.patched.PatchProfiler"/>
		</class>
		<class id="net.minecraft.network.NetServerHandler">
			<addAll fromClass="me.nallar.patched.network.PatchNetServerHandler"/>
			<replaceMethodCall method="warning"
												 code="{ javassist.is.faulty.Redirects.notifyAdmins($1); }"
							>handleFlying
			</replaceMethodCall>
			<insertBefore code="if (javassist.is.faulty.Redirects.interceptPacket($1, this)) { return; }">sendPacketToPlayer</insertBefore>
		</class>
		<class id="net.minecraft.network.NetServerHandler" env="mcpc">
			<insertAfter code="handleTeleport($1.getX(), $1.getY(), $1.getZ());">teleport</insertAfter>
			<synchronize>teleport</synchronize>
		</class>
		<class id="net.minecraft.network.NetServerHandler" env="forge">
			<insertAfter code="handleTeleport($1, $2, $3);">setPlayerLocation</insertAfter>
			<synchronize>setPlayerLocation</synchronize>
		</class>
		<class id="net.minecraft.network.packet.Packet10Flying">
			<addAll fromClass="me.nallar.patched.network.PatchPacket10Flying"/>
		</class>
		<class id="net.minecraft.network.packet.Packet14BlockDig">
			<addAll fromClass="me.nallar.patched.network.PatchPacketAsync"/>
		</class>
		<class id="net.minecraft.network.packet.Packet51MapChunk">
			<volatile field="chunkData"/>
			<addAll fromClass="me.nallar.patched.network.PatchPacket51MapChunk"/>
			<threadLocal field="temp" type="byte[]" threadLocalField="javassist.is.faulty.ThreadLocals.mapChunkTempByteArray">getMapChunkData</threadLocal>
			<synchronize field="$1">getMapChunkData</synchronize>
		</class>
		<class id="net.minecraft.network.packet.Packet56MapChunks">
			<volatile field="chunkDataBuffer"/>
		</class>
		<class id="net.minecraft.network.packet.Packet254ServerPing">
			<addAll fromClass="me.nallar.patched.network.PatchPacketAsync"/>
		</class>
		<class id="net.minecraft.network.NetworkListenThread">
			<synchronize>addPlayer,networkTick</synchronize>
			<profile>networkTick</profile>
		</class>
		<class id="net.minecraft.network.TcpWriterThread">
			<ignoreExceptions type="java.net.SocketException">run</ignoreExceptions>
		</class>
		<class id="net.minecraft.world.World">
			<addAll fromClass="me.nallar.patched.world.PatchWorld"/>
			<profile>updateEntities</profile>
			<profile>setActivePlayerChunksAndCheckLight</profile>
			<public>releaseEntitySkin</public>
			<final field="worldAccesses"/>
			<final field="provider"/>
			<final field="theProfiler"/>
			<final field="playerEntities"/>
			<final field="isRemote"/>
			<public field="ambientTickCountdown"/>
			<public field="forcedChunks"/>
			<replaceInitializer field="playerEntities" class="java.util.concurrent.CopyOnWriteArrayList"/>
			<insertBefore code="if (preHandleSpawn($1)) { return false; }">spawnEntityInWorld</insertBefore>
			<removeMethod>forceChunk,unforceChunk</removeMethod>
		</class>
		<class id="net.minecraft.world.ChunkCache">
			<replaceMethodCall code="$_ = $0.getChunkIfExists($$);" method="^class:World^.^method:World/getChunkFromChunkCoords^"/>
		</class>
		<class id="net.minecraft.world.NextTickListEntry">
			<newField static="" field="nextEntryID_" class="java.util.concurrent.atomic.AtomicLong"/>
			<insertAfter field="tickEntryID" code="this.$field = this.nextEntryID_.getAndIncrement();"/>
		</class>
		<class id="net.minecraft.world.WorldServer">
			<addAll fromClass="me.nallar.patched.world.PatchWorldServer"/>
			<profile>tickBlocksAndAmbiance</profile>
			<profile>tick</profile>
			<insertSuper>initialize</insertSuper>
			<synchronize>addBlockEvent,sendAndApplyBlockEvents</synchronize>
		</class>
		<class id="net.minecraft.world.biome.BiomeDecorator">
			<synchronize>decorate(Lnet/minecraft/world/World;Ljava/util/Random;II)V</synchronize>
		</class>
		<class id="net.minecraft.world.biome.WorldChunkManager">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">getModdedBiomeGenerators</synchronize>
		</class>
		<class id="net.minecraft.world.biome.BiomeCache">
			<synchronize>getBiomeCacheBlock,cleanupCache</synchronize>
		</class>
		<class id="net.minecraft.world.gen.layer.IntCache">
			<replace class="me.nallar.patched.storage.IntCache"/>
		</class>
		<class id="net.minecraft.world.gen.structure.MapGenStructure">
			<replaceInitializer field="structureMap" class="java.util.concurrent.ConcurrentHashMap"/>
		</class>
		<class id="net.minecraft.world.gen.ChunkProviderServer">
			<replace class="me.nallar.patched.storage.ThreadedChunkProvider"/>
			<lockToSynchronized>getChunkAtInternal</lockToSynchronized>
		</class>
		<class id="net.minecraft.world.gen.ChunkProviderServer" env="mcpc">
			<replaceMethod code="{
				world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent($1.bukkitChunk, $2));
			}
			">fireBukkitLoadEvent
			</replaceMethod>
			<replaceMethod code="{
				world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent($1.bukkitChunk));
			}
			">fireBukkitPopulateEvent
			</replaceMethod>
			<replaceMethod code="{
				org.bukkit.event.world.ChunkUnloadEvent event = new org.bukkit.event.world.ChunkUnloadEvent($1.bukkitChunk);
        world.getServer().getPluginManager().callEvent(event);

        return !event.isCancelled();
			}
			">fireBukkitUnloadEvent
			</replaceMethod>
		</class>
		<class id="org.bukkit.craftbukkit.v1_4_R1.chunkio.ChunkIOExecutor" env="mcpc">
			<replaceInitializer field="instance" code="$_ = null;"/>
			<replaceMethod code="throw new UnsupportedOperationException();">tick</replaceMethod>
			<disable>adjustPoolSize</disable>
			<replaceMethod code="((^class:ChunkProviderServer^)$1.^method:World/getChunkProvider^()).getChunkAt($2, $3, true, false, null);">waitForChunkLoad</replaceMethod>
			<replaceMethod code="$3.getChunkAt($4, $5, true, false, $6);">queueChunkLoad</replaceMethod>
		</class>
		<class id="net.minecraft.world.gen.ChunkProviderServer" env="mcpc">
			<changeFieldType field="chunksToUnload" type="org.bukkit.craftbukkit.v1_4_R1.util.LongHashSet" remove="true"/>
			<insertAfter field="chunksToUnload" code="$field = new org.bukkit.craftbukkit.v1_4_R1.util.LongHashSet();"/>
		</class>
		<class id="net.minecraft.world.chunk.NibbleArray" env="forge">
			<addAll fromClass="me.nallar.patched.storage.PatchNibbleArrayForge"/>
		</class>
		<class id="net.minecraft.world.chunk.storage.RegionFileCache">
			<replaceMethod code="throw new UnsupportedOperationException();">createOrLoadRegionFile</replaceMethod>
		</class>
		<class id="net.minecraft.world.chunk.storage.AnvilChunkLoader">
			<replace class="me.nallar.patched.storage.ThreadedChunkLoader"/>
		</class>
		<class id="net.minecraft.world.chunk.storage.AnvilChunkLoaderPending">
			<addAll fromClass="me.nallar.patched.storage.PatchAnvilChunkLoaderPending"/>
		</class>
		<class id="net.minecraft.world.chunk.Chunk">
			<!-- The entity list could be accessed from multiple threads, as usual causes problems during iteration -->
			<addAll fromClass="me.nallar.patched.storage.PatchChunk"/>
			<final field="xPosition"/>
			<final field="zPosition"/>
			<final field="entityLists"/>
			<final field="worldObj"/>
			<volatile field="isTerrainPopulated"/>
			<replaceInitializer field="chunkTileEntityMap" class="java.util.concurrent.ConcurrentHashMap"/>
			<!--
			Used to debug when mods are setting chunk.isModified when they shouldn't - for example, GregTech sets every chunk with a gregtech machine in as modified
			every tick. :(
			<replaceFieldUsage field="isModified" writeCode="$0.^field:Chunk/isModified^ = $1; if ($1 == true) { Thread.dumpStack(); }">^all^</replaceFieldUsage>
			-->
		</class>
		<class id="net.minecraft.world.chunk.EmptyChunk">
			<replaceMethod code="return 1;">getHeightValue</replaceMethod>
			<replaceMethod code="{ if ($2 == 0) { return 7; } return 0; }">getBlockID</replaceMethod>
		</class>
		<class id="net.minecraft.util.Vec3Pool">
			<!-- This prevents entities in multiple threads using the same Vec3 for collisions. -->
			<replace class="me.nallar.patched.PatchVec3Pool"/>
		</class>
		<class id="net.minecraft.util.AABBPool">
			<!-- This prevents entities in multiple threads using the same Vec3 for collisions. -->
			<replace class="me.nallar.patched.PatchAABBPool"/>
		</class>
		<class id="net.minecraft.util.AxisAlignedBB">
			<!-- Improves performance -->
			<addAll fromClass="me.nallar.patched.PatchAxisAlignedBB"/>
			<replaceInitializer field="theAABBLocalPool" code="$_ = null;">^static^</replaceInitializer>
		</class>
		<class id="net.minecraft.util.LongHashMap">
			<replace class="me.nallar.patched.collection.PatchLongHashMap"/>
		</class>
		<class id="net.minecraft.util.IntHashMap">
			<replace class="me.nallar.patched.collection.PatchIntHashMap"/>
		</class>
		<class id="net.minecraft.entity.passive.EntitySquid">
			<removeMethod>isInWater</removeMethod>
		</class>
		<class id="net.minecraft.entity.player.EntityPlayerMP">
			<addAll fromClass="me.nallar.patched.entity.PatchEntityPlayerMP"/>
			<!-- Concurrent access during iteration = boom -->
			<replaceInitializer field="destroyedItemsNetCache" class="me.nallar.collections.ConcurrentQueueList"/>
			<replaceInitializer field="loadedChunks" class="me.nallar.collections.ConcurrentQueueList"/>
		</class>
		<class id="net.minecraft.entity.player.EntityPlayerMP">
			<addAll fromClass="me.nallar.patched.entity.PatchEntityPlayerMPForge"/>
		</class>
		<class id="net.minecraft.entity.Entity">
			<addAll fromClass="me.nallar.patched.entity.PatchEntity"/>
		</class>
		<class id="net.minecraft.nbt.CompressedStreamTools">
			<addAll fromClass="me.nallar.patched.nbt.PatchCompressedStreamTools"/>
		</class>
		<class id="net.minecraft.nbt.NBTBase">
			<replaceMethod code="{
				byte id = $1.^method:NBTBase/getId^();
				$2.writeByte(id);

				if (id != 0) {
					$2.writeUTF($1.^method:NBTBase/getName^());
					if (id == 10) {
						synchronized ($1) {
							$1.^method:NBTBase/write^($2);
						}
					} else {
						$1.^method:NBTBase/write^($2);
					}
				}
			}">writeNamedTag
			</replaceMethod>
		</class>
		<class id="net.minecraft.nbt.NBTBase">
			<addAll fromClass="me.nallar.patched.nbt.PatchNBTBase"/>
		</class>
		<class id="net.minecraft.nbt.NBTTagCompound">
			<addAll fromClass="me.nallar.patched.nbt.PatchNBTTagCompound"/>
			<replaceInitializer field="tagMap" class="me.nallar.collections.PartiallySynchronizedMap"/>
			<final field="tagMap"/>
		</class>
		<class id="net.minecraft.entity.Entity">
			<final field="rand"/>
			<newField static="" field="nextEntityID_" class="java.util.concurrent.atomic.AtomicInteger"/>
			<insertAfter field="entityId" code="this.$field = this.nextEntityID_.getAndIncrement();"/>
			<insertBefore code="if ($1 == 0 &amp;&amp; $2 == 0 &amp;&amp; $3 == 0) { return; }">moveEntity</insertBefore>
		</class>
		<class id="net.minecraft.entity.EntityLiving">
			<addAll fromClass="me.nallar.patched.entity.PatchEntityLiving"/>
		</class>
		<class id="net.minecraft.entity.item.EntityItem">
			<addAll fromClass="me.nallar.patched.entity.PatchEntityItem"/>
			<insertSuper>onUpdate</insertSuper>
		</class>
		<class id="net.minecraft.tileentity.TileEntity">
			<addAll fromClass="me.nallar.patched.PatchTileEntity"/>
		</class>
		<class id="net.minecraft.entity.EntityTracker">
			<!-- Yet more comodification exceptions -->
			<addAll fromClass="me.nallar.patched.entity.PatchEntityTracker"/>
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">addEntityToTracker(Lnet/minecraft/entity/Entity;)V,addEntityToTracker(Lnet/minecraft/entity/Entity;IIZ)V,removeEntityFromAllTrackingPlayers</lock>
			<lock field="readLock">updateTrackedEntities,removeAllTrackingPlayers,func_85172_a</lock>
		</class>
		<class id="net.minecraft.village.Village">
			<addAll fromClass="me.nallar.patched.PatchVillage"/>
		</class>
		<class id="net.minecraft.village.VillageCollection">
			<addAll fromClass="me.nallar.patched.collection.PatchVillageCollection"/>
			<!-- Literally the most useless collection. Locking instead of voiding in case it ever does something useful in future -->
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">addVillagerPosition</lock>
			<lock field="readLock">findNearestVillage,func_82566_a</lock>
		</class>
		<class id="net.minecraft.server.dedicated.DedicatedServerSleepThread">
			<disable>run</disable>
		</class>
		<class id="net.minecraft.server.management.ServerConfigurationManager">
			<addAll fromClass="me.nallar.patched.server.PatchServerConfigurationManager"/>
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="playersUpdateLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="playerUpdateLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="playerUpdateLock">createPlayerForUser,sendPacketToAllPlayers,sendPlayerInfoToAllPlayers</lock>
			<lock field="playerUpdateLock">sendPacketToAllPlayersInDimension,getPlayerListAsString,getAllUsernames,getPlayerForUsername,findPlayers,sendToAllNearExcept</lock>
			<lock field="playerUpdateLock">saveAllPlayerData,getPlayerList</lock>
			<replaceInitializer field="playerEntityList" class="me.nallar.collections.LockArrayList"/>
			<insertAfter code="((me.nallar.collections.LockArrayList)^field:ServerConfigurationManager/playerEntityList^).lock = playersUpdateLock;"/>
			<synchronize field="$1.playerNetServerHandler">respawnPlayer</synchronize>
			<synchronize field="$1.^field:EntityPlayerMP/playerNetServerHandler^">transferPlayerToDimension(L^class:EntityPlayerMP^;IL^class:Teleporter^;)V</synchronize>
		</class>
		<class id="net.minecraft.server.management.ServerConfigurationManager" env="forge">
			<addAll fromClass="me.nallar.patched.server.PatchServerConfigurationManagerForge"/>
		</class>
		<class id="net.minecraft.server.management.PlayerManager">
			<addAll fromClass="me.nallar.patched.world.tracking.PatchPlayerManager"/>
			<replaceMethodCall method="sort" index="1" code="{ }">updateMountedMovingPlayer</replaceMethodCall>
			<synchronize>addPlayer,removePlayer</synchronize>
			<synchronize field="$1.loadedChunks">addPlayer,removePlayer,filterChunkLoadQueue</synchronize>
			<synchronize field="$1.loadedChunks">updateMountedMovingPlayer</synchronize>
			<profile>updatePlayerInstances</profile>
		</class>
		<class id="net.minecraft.server.management.PlayerInstance" env="forge">
			<replaceMethodCall method="^class:ChunkProviderServer^.^method:ChunkProviderServer/loadChunk^" code="{ $_ = null; }"/>
		</class>
		<class id="net.minecraft.server.management.PlayerInstance">
			<replaceInitializer field="playersInChunk" code="$_ = Collections.synchronizedList(new ArrayList());"/>
			<replaceMethodCall method="^class:PlayerManager^.^method:PlayerManager/getWorldServer^" removeAfter="true"/>
			<addAll fromClass="me.nallar.patched.world.tracking.PatchPlayerInstance"/>
			<public field="loaded"/>
			<final field="chunkLocation"/>
		</class>
		<class id="net.minecraft.world.ChunkCoordIntPair">
			<addAll fromClass="me.nallar.patched.storage.PatchChunkCoordIntPair"/>
			<public field="chunkXPos"/>
			<public field="chunkZPos"/>
			<noFinal field="chunkXPos"/>
			<noFinal field="chunkZPos"/>
		</class>
		<class id="net.minecraft.world.Teleporter">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:WorldServer^.^method:World/getBlockTileEntity^">^all^</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:WorldServer^.^method:World/getBlockId^">^all^</replaceMethodCall>
		</class>
		<class id="net.minecraft.crash.CrashReport">
			<addAll fromClass="me.nallar.patched.server.PatchCrashReport"/>
		</class>
		<class id="net.minecraft.block.BlockRedstoneTorch">
			<addAll fromClass="me.nallar.patched.block.PatchBlockRedstoneTorch"/>
		</class>
		<class id="net.minecraft.block.BlockRedstoneWire">
			<synchronize>calculateCurrentChanges,updateAndPropagateCurrentStrength</synchronize>
		</class>
		<class id="net.minecraft.block.BlockFlowing">
			<!--
				TODO: Make this cleaner once it's possible to access method parameters while replacing a MethodCall expression.
				See https://issues.jboss.org/browse/JASSIST-197
			-->
			<replaceMethodCall
							code="if (((org.bukkit.craftbukkit.v1_4_R1.CraftWorld) ((org.bukkit.event.block.BlockEvent) $1).getBlock().getWorld()).getHandle().safeToGenerate()) { $0.callEvent($$); }"
							method="callEvent">updateTick
			</replaceMethodCall>
		</class>
		<class id="net.minecraft.network.TcpConnection">
			<addAll fromClass="me.nallar.patched.network.PatchTcpConnection"/>
		</class>
		<class id="net.minecraft.network.TcpReaderThread">
			<replace class="me.nallar.patched.network.ReplaceTcpReaderThread"/>
		</class>
		<class id="net.minecraft.entity.ai.EntityAITasks">
			<synchronize>addTask,func_85156_a,onUpdateTasks,func_75775_b</synchronize>
		</class>
		<class id="net.minecraft.block.Block" env="mcpc">
			<threadLocalBoolean field="callingPlaceEvent" threadLocalField="$0.inPlaceEvent"/>
		</class>
		<class id="net.minecraft.world.World" env="mcpc">
			<insertBefore code="inPlaceEvent = new me.nallar.tickthreading.util.BooleanThreadLocal();"/>
			<final field="callingPlaceEvent"/>
			<threadLocalBoolean field="callingPlaceEvent" threadLocalField="$0.inPlaceEvent"/>
			<disable>loadChunkOnProvideBegin,loadChunkOnProvideEnd</disable>
		</class>
		<class id="net.minecraft.world.chunk.Chunk" env="mcpc">
			<threadLocalBoolean field="callingPlaceEvent" threadLocalField="$0.inPlaceEvent"/>
		</class>
		<class id="net.minecraft.item.ItemBlock" env="mcpc">
			<threadLocalBoolean field="callingPlaceEvent" threadLocalField="$0.inPlaceEvent"/>
		</class>
		<class id="net.minecraft.server.gui.GuiLogOutputHandler">
			<synchronize>publish</synchronize>
		</class>
	</minecraftCommon>
	<forge>
		<class id="net.minecraftforge.common.DimensionManager">
			<addAll fromClass="me.nallar.patched.forge.PatchDimensionManager"/>
			<synchronize field="unloadQueue">unloadWorld</synchronize>
			<insertBefore code="if (getWorld($1) != null) { return; }">initDimension</insertBefore>
			<synchronize>unloadWorlds,initDimension,setWorld</synchronize>
			<insertAfter code="if ($2 != null) { $2.setDimension($1); }">setWorld</insertAfter>
		</class>
		<class id="net.minecraftforge.common.DimensionManager" env="mcpc">
			<replaceMethod code="{
				org.bukkit.event.world.WorldUnloadEvent e = new org.bukkit.event.world.WorldUnloadEvent($1.getWorld());
				org.bukkit.Bukkit.getServer().getPluginManager().callEvent(e);
				return e.isCancelled();
			}
			">fireBukkitWorldUnload
			</replaceMethod>
			<replaceMethod code="{
				org.bukkit.Bukkit.getServer().getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent($1.getWorld()));
			}
			">fireBukkitWorldSave
			</replaceMethod>
			<replaceMethod code="{
				java.lang.reflect.Field field = org.bukkit.Bukkit.getServer().getClass().getDeclaredField(&quot;worlds&quot;);
				field.setAccessible(true);
				((java.util.Map) field.get(org.bukkit.Bukkit.getServer())).values().remove($1.getWorld());
			}
			">removeBukkitWorld
			</replaceMethod>
			<removeUntilOpcode opcode="return" index="1">initDimension</removeUntilOpcode>
		</class>
	</forge>
	<bukkit>
		<class id="org.bukkit.plugin.SimplePluginManager">
			<synchronize>subscribeToPermission,unsubscribeFromPermission,subscribeToDefaultPerms,unsubscribeFromDefaultPerms,getPermissionSubscriptions,getDefaultPermSubscriptions</synchronize>
		</class>
		<class id="org.bukkit.craftbukkit.v1_4_R1.CraftServer">
			<replaceMethodCall method="registerDimension" code="{ }">createWorld(Lorg.bukkit.WorldCreator;)Lorg.bukkit.World;</replaceMethodCall>
			<replaceMethodCall method="addMVDimension" code="{ }">createWorld(Lorg.bukkit.WorldCreator;)Lorg.bukkit.World;</replaceMethodCall>
			<ignoreExceptions code="System.err.println(&quot;Loading world failed&quot; + $e); $e.printStackTrace(); throw new java.lang.Error($e);">
				createWorld(Lorg.bukkit.WorldCreator;)Lorg.bukkit.World;
			</ignoreExceptions>
			<replaceMethod code="{
				return net.minecraftforge.common.DimensionManager.unloadWorld(((org.bukkit.craftbukkit.v1_4_R1.CraftWorld) $1).getHandle(), $2);
			}">unloadWorld(Lorg.bukkit.World;Z)V
			</replaceMethod>
		</class>
		<class id="org.bukkit.craftbukkit.v1_4_R1.CraftWorld">
			<replaceMethod
							code=" {
							Object[] chunks = world.getChunks();
							org.bukkit.Chunk[] craftChunks = new org.bukkit.Chunk[chunks.length];
							for (int i = 0; i &lt; craftChunks.length; i++) {
								craftChunks[i] = ((zz) chunks[i]).bukkitChunk;
							}
							return craftChunks;
							} "
							>getLoadedChunks
			</replaceMethod>
			<replaceFieldUsage class="^class:WorldServer^" field="^field:World/loadedEntityList^" readCode="$_ = world.getEntities();">
				getLivingEntities,getEntities,getEntitiesByClass(Ljava.lang.Class;)Ljava.util.Collection;,getEntitiesByClasses
			</replaceFieldUsage>
			<replaceFieldUsage class="^class:WorldServer^" field="^field:World/loadedEntityList^" readCode="$_ = world.getPlayerEntities();">getPlayers</replaceFieldUsage>
			<replaceMethod
							code=" {
								return world.^field:WorldServer/theChunkProviderServer^.getChunkAt($1, $2, $3, null) != null;
							} "
							>loadChunk(IIZ)Z
			</replaceMethod>
			<replaceMethod
							code=" {
								if ($4 &amp;&amp; isChunkInUse($1, $2)) {
										return false;
								}

								world.^field:WorldServer/theChunkProviderServer^.unloadChunkImmediately($1, $2, $3);

								return true;
							} "
							>unloadChunk(IIZZ)Z
			</replaceMethod>
			<replaceMethod
							code=" {
								world.^field:WorldServer/theChunkProviderServer^.regenerateChunk($1, $2);

								refreshChunk($1, $2);

								return true;
							} "
							>regenerateChunk
			</replaceMethod>
			<replaceMethod code="throw new UnsupportedOperationException(&quot;Not threadsafe.&quot;);">chunkLoadPostProcess</replaceMethod>
			<disable>processChunkGC</disable>
		</class>
	</bukkit>
	<spigot>
		<class id="org.bukkit.craftbukkit.v1_4_R1.util.WatchdogThread">
			<disable>run</disable>
		</class>
	</spigot>
	<forge>
		<class id="net.minecraftforge.common.Configuration">
			<addAll fromClass="me.nallar.patched.forge.PatchConfiguration"/>
		</class>
		<class id="net.minecraftforge.common.ConfigCategory">
			<addAll fromClass="me.nallar.patched.forge.PatchConfigCategory"/>
		</class>
		<class id="net.minecraftforge.event.Event">
			<final field="listeners"/>
			<removeField field="annotationMap"/>
			<addAll fromClass="me.nallar.patched.forge.PatchEvent"/>
		</class>
		<class id="net.minecraftforge.common.ForgeChunkManager$Ticket">
			<public all="true"/>
		</class>
		<class id="net.minecraftforge.common.ForgeChunkManager" env="mcpc">
			<removeFieldAndInitializers field="forcedChunks" silent="true"/>
		</class>
		<class id="net.minecraftforge.common.ForgeChunkManager">
			<addAll fromClass="me.nallar.patched.forge.PatchForgeChunkManager"/>
		</class>
	</forge>
	<forgeModLoader>
		<class id="cpw.mods.fml.common.registry.GameRegistry">
			<addAll fromClass="me.nallar.patched.forge.PatchGameRegistry"/>
		</class>
		<class id="cpw.mods.fml.common.registry.TickRegistry">
			<addAll fromClass="me.nallar.patched.forge.PatchTickRegistry"/>
		</class>
		<class id="cpw.mods.fml.relauncher.FMLLogFormatter">
			<replace class="me.nallar.tickthreading.LogFormatter"/>
		</class>
		<class id="cpw.mods.fml.common.event.FMLInterModComms$IMCMessage">
			<addAll fromClass="me.nallar.patched.forge.PatchIMCMessage"/>
		</class>
		<class id="cpw.mods.fml.common.Loader">
			<addAll fromClass="me.nallar.patched.forge.PatchLoader"/>
		</class>
		<class id="cpw.mods.fml.common.Loader$ModIdComparator">
			<public/>
		</class>
		<class id="cpw.mods.fml.common.asm.FMLSanityChecker">
			<replaceMethodCall code="{ $_ = null; }" method="severe">call</replaceMethodCall>
		</class>
		<class id="cpw.mods.fml.common.FMLModContainer">
			<replaceMethodCall index="0" code="{ $_ = null; }" method="log">constructMod</replaceMethodCall>
			<replaceFieldUsage field="fingerprintNotPresent" readCode="$_ = false;">constructMod</replaceFieldUsage>
		</class>
		<class id="cpw.mods.fml.common.registry.BlockTracker">
			<synchronize>getNextBlockId,doReserveId</synchronize>
		</class>
		<class id="cpw.mods.fml.common.FMLCommonHandler">
			<addAll fromClass="me.nallar.patched.forge.PatchFMLCommonHandler"/>
			<profile>onPreServerTick,onPostServerTick,onPreWorldTick,onPostWorldTick</profile>
		</class>
		<class id="cpw.mods.fml.relauncher.RelaunchClassLoader">
			<addAll fromClass="me.nallar.patched.forge.PatchRelaunchClassLoader"/>
			<synchronize>findClass</synchronize>
		</class>
		<class id="cpw.mods.fml.common.network.PacketDispatcher">
			<addAll fromClass="me.nallar.patched.forge.PatchPacketDispatcher"/>
		</class>
		<class id="cpw.mods.fml.common.network.ModListResponsePacket">
			<replaceMethodCall index="2" code="{ $_ = null; }" method="info">execute</replaceMethodCall>
		</class>
	</forgeModLoader>
	<factorization>
		<class id="factorization.common.TileEntityBarrel">
			<replaceMethod code="{
				^class:ItemStack^ i = this.item;
				^class:ItemStack^ t = this.topStack;
				^class:ItemStack^ b = this.bottomStack;
				if (i == null) {
					return 0;
				}
				if ((t == null) || (!itemMatch(t))) {
					t = i.l();
					t.a = 0;
					this.topStack = t;
				}
				if ((b == null) || (!itemMatch(b))) {
					b = this.item.l();
					b.a = 0;
					this.bottomStack = b;
				}
				return t.a + this.middleCount + b.a;
			}">getItemCount
			</replaceMethod>
			<synchronize>updateStacks,changeItemCount,setItemCount</synchronize>
		</class>
		<class id="factorization.common.TileEntityWrathLamp">
			<replaceInitializer field="airToUpdate" class="me.nallar.collections.SynchronizedPriorityQueue">^static^</replaceInitializer>
			<threadLocal field="toVisit" type="java.util.HashSet" threadLocalField="javassist.is.faulty.ThreadLocals.factorizationFindLightAirParentToVisit"/>
			<replaceMethodCall code="$_ = $0.getChunkFromBlockCoordsIfExists($$);" method="^class:World^.^method:World/getChunkFromBlockCoords^">findLightAirParent</replaceMethodCall>
		</class>
		<class id="factorization.api.Charge">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">update</synchronize>
		</class>
		<class id="factorization.common.TileEntityBarrel">
			<synchronize>a(ILur;)V</synchronize>
		</class>
	</factorization>
	<liteLoader>
		<class id="com.mumfrey.liteloader.core.HookProfiler">
			<!-- LiteLoader makes the profiler not threadsafe - I may look into patching this better in future, but TT isn't really intended for clients -->
			<synchronize>a(Ljava/lang/String;)V,b()V</synchronize>
		</class>
	</liteLoader>
	<buildCraftCore>
		<class id="buildcraft.core.inventory.TransactorSimple">
			<replaceMethod code="{
				int injected = 0;

				int slotIndex = 0;
				int slot = 0;
				int size = inventory.^method:IInventory/getSizeInventory^();
				while (slotIndex &lt; size &amp;&amp; injected &lt; $1.^field:ItemStack/stackSize^) {
					slot = getPartialSlot($1, $2, slotIndex++);
					if (slot != -1){
						injected += addToSlot(slot, $1, injected, $3);
					}
				}

				slotIndex = 0;
				while (slotIndex &lt; size &amp;&amp; injected &lt; $1.^field:ItemStack/stackSize^) {
					slotIndex++;
					slot = getEmptySlot($2);
					if (slot != -1){
						injected += addToSlot(slot, $1, injected, $3);
					}
				}
				if (injected > 0) {
					inventory.^method:IInventory/onInventoryChanged^();
				}
				return injected;
			}">inject
			</replaceMethod>
		</class>
	</buildCraftCore>
	<buildCraftEnergy>
		<class id="buildcraft.energy.TileEngine">
			<synchronize>createEngineIfNeeded</synchronize>
			<insertBefore code="if ($1 &gt; 2 || $1 &lt; 0) { $1 = 0; }">newEngine</insertBefore>
		</class>
	</buildCraftEnergy>
	<buildCraftFactory>
		<class id="buildcraft.BuildCraftFactory$QuarryChunkloadCallback">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">ticketsLoaded(Ljava.util.List;L^class:World^;)V</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;</replaceMethodCall>
		</class>
		<class id="buildcraft.factory.TilePump">
			<replaceInitializer field="blocksToPump" class="me.nallar.collections.TreeMapHashMap"/>
			<insertBefore code="blocksToPump.clear();">initializePumpFromPosition</insertBefore>
			<synchronize>isActive,getNextIndexToPump</synchronize>
		</class>
	</buildCraftFactory>
	<buildCraftTransport>
		<class id="buildcraft.transport.TileGenericPipe">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">initialize</synchronize>
			<synchronize field="facadeBlocks">blockCreated,getBlockId,getTile,computeConnections</synchronize>
		</class>
		<class id="buildcraft.transport.PipeTransportItems">
			<replaceInitializer field="travelingEntities" class="java.util.concurrent.ConcurrentHashMap"/>
			<replaceInitializer field="toRemove" class="me.nallar.collections.SynchronizedSet"/>
			<replaceMethod code="{
				synchronized(toRemove) {
					java.util.Iterator i = toRemove.iterator();
					while (i.hasNext()) {
						travelingEntities.remove(i.next());
					}
					toRemove.clear();
				}
			}">performRemoval
			</replaceMethod>
		</class>
		<class id="buildcraft.transport.PipeTransportPower">
			<!-- TODO: Non-static lock, if possible -->
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">updateEntity</synchronize>
		</class>
	</buildCraftTransport>
	<thermalExpansionTransport>
		<class id="thermalexpansion.transport.tileentity.TileConduitEnergy">
			<newField field="tickLock" class="java.lang.Object" static=""/>
			<synchronize field="tickLock">updateGridIfNull</synchronize>
		</class>
		<class id="thermalexpansion.transport.tileentity.TileConduitLiquid">
			<newField field="tickLock" class="java.lang.Object" static=""/>
			<synchronize field="tickLock">updateGridIfNull</synchronize>
		</class>
		<class id="thermalexpansion.transport.GridLiquid">
			<synchronize>transferLiquid,removeNode,removeConduit,setNewGrid,changeMode,increaseTracker,addNode,addConduit</synchronize>
		</class>
		<class id="thermalexpansion.transport.GridEnergy">
			<synchronize>transferEnergy,removeNode,removeConduit,setNewGrid,changeMode,increaseTracker,addNode,addConduit</synchronize>
		</class>
	</thermalExpansionTransport>
	<thremalExpansionFactory>
		<class id="thermalexpansion.factory.tileentity.TilePortableTank">
			<replaceMethod code="{
				if (this.myTank.getLiquidAmount() &lt;= 0) {
					return;
				}

				int[] coords = cofh.core.BlockUtils.getAdjacentCoordinatesForSide(this.l, this.m, this.n, 0);

				any theTile = this.k.q(coords[0], coords[1], coords[2]);
				if (theTile instanceof net.minecraftforge.liquids.ITankContainer) {
					if (theTile instanceof thermalexpansion.factory.tileentity.TilePortableTank &amp;&amp;
							!((((thermalexpansion.factory.tileentity.TilePortableTank)theTile).myTank.getLiquidID() &lt;= 0) ||
							(((thermalexpansion.factory.tileentity.TilePortableTank)theTile).myTank.getLiquidAmount() != 8000))) {
						return;
					}
					int fillQty = Math.min(this.myTank.getLiquidAmount(), 250);
					int quantity = ((net.minecraftforge.liquids.ITankContainer)theTile).fill(net.minecraftforge.common.ForgeDirection.UP, new net.minecraftforge.liquids.LiquidStack(this.myTank.getLiquidID(), fillQty, this.myTank.getLiquidMeta()), true);
					if (quantity &gt; 0) {
						this.myTank.drain(quantity, true);
					}
				}
			}">transferLiquid
			</replaceMethod>
		</class>
	</thremalExpansionFactory>
	<redPowerCore>
		<class id="com.eloraam.redpower.core.RedPowerLib">
			<threadLocal field="blockUpdates" type="java.util.HashSet" threadLocalField="javassist.is.faulty.ThreadLocals.redPowerBlockUpdateSet"/>
			<threadLocal field="powerSearchTest" type="java.util.HashSet" threadLocalField="javassist.is.faulty.ThreadLocals.redPowerPowerSearchTest"/>
			<threadLocal field="powerSearch" type="java.util.LinkedList" threadLocalField="javassist.is.faulty.ThreadLocals.redPowerPowerSearch"/>
			<threadLocalBoolean field="searching" threadLocalField="javassist.is.faulty.ThreadLocals.redPowerIsSearching"/>
		</class>
		<class id="com.eloraam.redpower.core.TileExtended">
			<replaceMethod code="this.sendTile();">updateBlock</replaceMethod>
			<replaceMethod code="this.sendTileWithNotify();">updateBlockChange</replaceMethod>
		</class>
		<class id="com.eloraam.redpower.core.TubeBuffer">
			<synchronize>onRemove,pop,addNew,addNewColor,addBounce,addAll,getLast,readFromNBT,writeToNBT</synchronize>
		</class>
		<class id="com.eloraam.redpower.core.TubeFlow">
			<replaceInitializer field="contents" class="me.nallar.collections.ConcurrentLinkedQueueList"/>
			<replaceInitializer field="contents" code="contents.clear(); $_ = null;">readFromNBT</replaceInitializer>
			<replaceFieldUsage field="contents" writeCode="{ }">readFromNBT</replaceFieldUsage>
			<final field="contents"/>
		</class>
		<class id="com.eloraam.redpower.core.PipeLib">
			<replaceMethodCall index="0" code="{ $_ = null; }" method="printf">registerForgeFluid</replaceMethodCall>
		</class>
	</redPowerCore>
	<redPowerMechanical>
		<class id="com.eloraam.redpower.machine.TileMotor">
			<replaceFieldUsage class="^class:World^" field="^field:World/isRemote^" writeCode="{ }" readCode="{ $_ = false; }">dropFrame,pickFrame</replaceFieldUsage>
			<replaceMethodCall newMethod="setBlockAndMetadataWithUpdateWithoutValidate" method="^class:World^.^method:World/setBlockAndMetadataWithUpdate^">dropFrame,pickFrame</replaceMethodCall>
		</class>
		<class id="com.eloraam.redpower.machine.TileTranspose">
			<synchronize field="buffer">drainBuffer</synchronize>
		</class>
	</redPowerMechanical>
	<industrialCraft>
		<class id="ic2.core.IC2">
			<synchronize>addSingleTickCallback</synchronize>
		</class>
		<class id="ic2.core.EnergyNet">
			<replaceMethodCall method="warning" code="{}">emitEnergyFrom</replaceMethodCall>
			<replaceInitializer field="energySourceToEnergyPathMap" class="java.util.HashMap"/>
			<replaceInitializer field="entityLivingToShockEnergyMap" class="java.util.HashMap"/>
			<synchronize>addTileEntity,removeTileEntity,emitEnergyFrom,discover</synchronize>
		</class>
		<class id="ic2.core.ExplosionIC2">
			<synchronize>doExplosion</synchronize>
		</class>
		<class id="ic2.core.block.wiring.TileEntityElectricBlock">
			<replaceMethodCall method="self.^method:TileEntity/onInventoryChanged^" code="{ }">^method:TileEntity/updateEntity^</replaceMethodCall>
		</class>
		<class id="ic2.core.network.NetworkManager">
			<replaceMethodCall method="cpw.mods.fml.common.network.PacketDispatcher.sendPacketToPlayer" code="javassist.is.faulty.Redirects.interceptIC2Packet($$);">
				announceBlockUpdate,initiateTileEntityEvent,initiateExplosionEffect
			</replaceMethodCall>
			<insertBefore code="javassist.is.faulty.Redirects.interceptIC2PacketIn($1, $2, $3);">onPacketData</insertBefore>
			<replaceMethod code="{
      byte[] var10000;
      try {
         java.io.ByteArrayOutputStream e = new java.io.ByteArrayOutputStream();
         e.write(0);
         java.util.zip.GZIPOutputStream gzip = new java.util.zip.GZIPOutputStream(e);
         java.io.DataOutputStream os = new java.io.DataOutputStream(gzip);
         os.writeInt(((^class:EntityPlayerMP^) $2).^field:EntityPlayerMP/playerNetServerHandler^.clientDimension);
         java.util.Iterator i$ = $1.iterator();
         int done = 0;

         do {
            ic2.core.network.NetworkManager$TileEntityField tef = (ic2.core.network.NetworkManager$TileEntityField)i$.next();
            if (!tef.te.r() &amp;&amp; tef.te.k == $2.p &amp;&amp; (tef.target == null || tef.target == $2)) {
               int distance = Math.min(Math.abs(tef.te.l - (int)$2.t), Math.abs(tef.te.n - (int)$2.v));
               if (distance &lt;= net.minecraft.server.MinecraftServer.D().ad().a() + 16) {
                  os.writeInt(tef.te.l);
                  os.writeInt(tef.te.m);
                  os.writeInt(tef.te.n);
                  os.writeShort(tef.field.length());
                  os.writeChars(tef.field);
                  java.lang.reflect.Field field = null;

                  try {
                     Class e1 = tef.te.getClass();

                     do {
                        try {
                           field = e1.getDeclaredField(tef.field);
                        } catch (NoSuchFieldException var14) {
                           e1 = e1.getSuperclass();
                        }
                     } while(field == null &amp;&amp; e1 != Object.class);

                     if (field == null) {
                        throw new NoSuchFieldException(tef.field);
                     }

                     field.setAccessible(true);
                     ic2.core.network.DataEncoder.encode(os, field.get(tef.te));
                  } catch (Exception var15) {
                     throw new RuntimeException(var15);
                  }
               }
            }
         } while (i$.hasNext() &amp;&amp; done++ &lt; 10000);
         os.close();
         gzip.close();
         return e.toByteArray();
      } catch (java.io.IOException var16) {
         throw new RuntimeException(var16);
      }
   }">getFieldData
			</replaceMethod>
			<replaceMethod code="{
				ic2.core.WorldData worldData = ic2.core.WorldData.get($1);
				Collection networkedFieldsToUpdate = worldData.networkedFieldsToUpdate;

				if (worldData.networkedFieldsToUpdate.isEmpty()) return;

				Collection networkedFieldsToUpdateList;
				synchronized(networkedFieldsToUpdate) {
				  networkedFieldsToUpdateList = new ArrayList(networkedFieldsToUpdate);
				  networkedFieldsToUpdate.clear();
				}

				for (Iterator i$ = $1.h.iterator(); i$.hasNext(); ) { Object obj = i$.next();
					iq entityPlayer = (iq)obj;

					sendUpdatePacket(networkedFieldsToUpdateList, entityPlayer);
				}
			}">sendUpdatePacket(L^class:World^;)V
			</replaceMethod>
		</class>
		<class id="ic2.core.WorldData">
			<replaceInitializer field="networkedFieldsToUpdate" class="me.nallar.collections.SynchronizedSet"/>
		</class>
	</industrialCraft>
	<gregTech>
		<class id="gregtechmod.GT_Mod">
			<synchronize>readIDSUData,writeIDSUData</synchronize>
			<replaceInitializer fieldClass="gregtechmod.common.tileentities.GT_TileEntity_IDSU" field="sEnergyList" class="me.nallar.collections.CHashMap">readIDSUData</replaceInitializer>
		</class>
		<class id="gregtechmod.common.tileentities.GT_TileEntityMetaID_Machine">
			<replaceMethodCall method="self.^method:TileEntity/onInventoryChanged^" code="{ }">^method:TileEntity/updateEntity^</replaceMethodCall>
		</class>
		<class id="gregtechmod.common.tileentities.GT_TileEntity_IDSU">
			<replaceMethodCall method="remove" code="{ $_ = null; }">setEnergyVar</replaceMethodCall>
		</class>
		<class id="gregtechmod.api.BaseMetaTileEntityMJ">
			<synchronize>updateStatus,getPowerProvider,setPowerProvider</synchronize>
			<replaceMethod code="{
				buildcraft.api.power.IPowerProvider powerProvider = getPowerProvider();
				if (powerProvider == null) {
					return 0;
				}
				return Math.min(powerProvider.getMaxEnergyReceived(), (int) (powerProvider.getMaxEnergyStored() - powerProvider.getEnergyStored() + 0.5f));
			}">powerRequest
			</replaceMethod>
		</class>
	</gregTech>
	<chickenChunks>
		<class id="codechicken.chunkloader.ChunkLoaderManager">
			<disable>cleanChunks</disable>
			<disable>tickEnd</disable>
			<newMethod code="
			public static void serverTick() {
        if (^class:MinecraftServer^.^method:MinecraftServer/getServer^().currentTick % 1200 == 0) {
        	updateLoginTimes();
        }
      	tickDownUnloads();
      	revivePlayerLoaders();
			}
			"/>
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">^all^</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">^all^</replaceMethodCall>
		</class>
		<class id="codechicken.chunkloader.ChunkLoaderEventHandler">
			<replaceMethod code="return java.util.EnumSet.of(cpw.mods.fml.common.TickType.SERVER, cpw.mods.fml.common.TickType.WORLD);">ticks</replaceMethod>
			<replaceMethod code="{
			if($1.contains(cpw.mods.fml.common.TickType.SERVER)) {
			   codechicken.chunkloader.ChunkLoaderManager.serverTick();
         codechicken.chunkloader.PlayerChunkViewerManager.instance().update();
      }

      if($1.contains(cpw.mods.fml.common.TickType.WORLD)) {
         codechicken.chunkloader.PlayerChunkViewerManager.instance().calculateChunkChanges((^class:WorldServer^)$2[0]);
      }
			}">tickEnd
			</replaceMethod>
		</class>
		<class id="codechicken.chunkloader.PlayerChunkViewerManager">
			<replaceInitializer field="ticketIDs" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="lastLoadedChunkMap" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="playerViewers" class="me.nallar.collections.ConcurrentLinkedQueueList"/>
			<replaceInitializer field="chunkChanges" class="me.nallar.collections.LinkedListIterateClear"/>
			<replaceInitializer field="ticketChanges" class="me.nallar.collections.LinkedListIterateClear"/>
			<replaceInitializer field="dimChanges" class="me.nallar.collections.LinkedListIterateClear"/>
			<replaceInitializer field="logouts" class="me.nallar.collections.LinkedListIterateClear"/>
			<replaceInitializer field="addViewers" class="me.nallar.collections.LinkedListIterateClear"/>
			<replaceMethod code="{
				++time;
				me.nallar.collections.LinkedListIterateClear logouts = (me.nallar.collections.LinkedListIterateClear) this.logouts;
				Iterator var2 = logouts.clearIterator();
				ArrayList temp = new ArrayList(logouts.size() + 3);
				while (var2.hasNext()) {
					temp.add(var2.next());
				}

				var2 = temp.iterator();
				String username;
				while(var2.hasNext()) {
					username = (String)var2.next();
					Iterator player = playerViewers.iterator();

					while(player.hasNext()) {
						if(((codechicken.chunkloader.PlayerChunkViewerTracker)player.next()).owner.^field:EntityPlayer/username^.equals(username)) {
							player.remove();
						}
					}
				}

				var2 = temp.iterator();

				Iterator var4;
				codechicken.chunkloader.PlayerChunkViewerTracker player1;
				while(var2.hasNext()) {
					username = (String)var2.next();
					var4 = playerViewers.iterator();

					while(var4.hasNext()) {
						player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
						player1.removePlayer(username);
					}
				}

				me.nallar.collections.LinkedListIterateClear dimChanges = (me.nallar.collections.LinkedListIterateClear) this.dimChanges;
				var2 = dimChanges.clearIterator();
				ArrayList tempDim = new ArrayList(dimChanges.size() + 3);
				while (var2.hasNext()) {
					tempDim.add(var2.next());
				}

				var2 = tempDim.iterator();
				codechicken.chunkloader.PlayerChunkViewerManager$DimensionChange username1;
				while(var2.hasNext()) {
					username1 = (codechicken.chunkloader.PlayerChunkViewerManager$DimensionChange)var2.next();
					if(username1.add) {
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.loadDimension(username1.world);
						}
					}
				}

				me.nallar.collections.LinkedListIterateClear chunkChanges = (me.nallar.collections.LinkedListIterateClear) this.chunkChanges;

				var2 = chunkChanges.clearIterator();

				while(var2.hasNext()) {
					codechicken.chunkloader.PlayerChunkViewerManager$ChunkChange username2 = (codechicken.chunkloader.PlayerChunkViewerManager$ChunkChange)var2.next();
					var4 = playerViewers.iterator();

					while(var4.hasNext()) {
						player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
						player1.sendChunkChange(username2);
					}
				}

				me.nallar.collections.LinkedListIterateClear ticketChanges = (me.nallar.collections.LinkedListIterateClear) this.ticketChanges;
				var2 = ticketChanges.clearIterator();

				while(var2.hasNext()) {
					codechicken.chunkloader.PlayerChunkViewerManager$TicketChange username3 = (codechicken.chunkloader.PlayerChunkViewerManager$TicketChange)var2.next();
					if(ticketIDs.containsKey(username3.ticket)) {
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.sendTicketChange(username3);
						}
					} else {
						ticketIDs.put(username3.ticket, Integer.valueOf(ticketID++));
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.addTicket(codechicken.core.CommonUtils.getDimension(username3.ticket.world), username3.ticket);
						}
					}
				}

				var2 = tempDim.iterator();

				while(var2.hasNext()) {
					username1 = (codechicken.chunkloader.PlayerChunkViewerManager$DimensionChange)var2.next();
					if(!username1.add) {
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.unloadDimension(codechicken.core.CommonUtils.getDimension(username1.world));
						}
					}
				}

				if(time % 10 == 0) {
					var2 = codechicken.core.ServerUtils.getAllPlayers().iterator();

					while(var2.hasNext()) {
						^class:EntityPlayer^ username4 = (^class:EntityPlayer^)var2.next();
						var4 = playerViewers.iterator();

						while(var4.hasNext()) {
							player1 = (codechicken.chunkloader.PlayerChunkViewerTracker)var4.next();
							player1.updatePlayer(username4);
						}
					}
				}


				var2 = ((me.nallar.collections.LinkedListIterateClear) this.addViewers).clearIterator();

				while(var2.hasNext()) {
					username = (String)var2.next();
					^class:EntityPlayerMP^ player2 = codechicken.core.ServerUtils.getPlayer(username);
					if(player2 != null) {
						playerViewers.add(new codechicken.chunkloader.PlayerChunkViewerTracker(player2, this));
					}
				}
			 }">update
			</replaceMethod>
			<synchronize>update</synchronize>
			<synchronize field="$1.b.g">calculateChunkChanges</synchronize>
		</class>
		<class id="codechicken.chunkloader.ChunkLoaderManager$ChunkLoaderOrganiser">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">^all^</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">^all^</replaceMethodCall>
			<synchronize>revive(L^class:World^;)V,devive,revive()V,load,save</synchronize>
			<replaceInitializer field="dormantLoaders" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="forcedChunksByChunk" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="forcedChunksByLoader" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="timedUnloadQueue" class="me.nallar.collections.LinkedTimedHashMapQueue"/>
		</class>
		<class id="codechicken.core.world.WorldExtension">
			<replaceInitializer field="chunkMap" class="me.nallar.collections.CHashMap"/>
		</class>
		<class id="codechicken.xycraftcopy.core.world.WorldExtension">
			<replaceInitializer field="chunkMap" class="me.nallar.collections.CHashMap"/>
		</class>
		<class id="codechicken.core.world.WorldExtensionManager$WorldExtensionEventHandler">
			<synchronize>onChunkLoad,onChunkUnLoad,onChunkDataLoad,onChunkDataSave</synchronize>
		</class>
		<class id="codechicken.xycraftcopy.core.world.WorldExtensionManager$WorldExtensionEventHandler">
			<synchronize>onChunkLoad,onChunkUnLoad,onChunkDataLoad,onChunkDataSave</synchronize>
		</class>
		<class id="codechicken.core.CommonUtils">
			<replaceMethod code="return $1.dimensionId;">getDimension(L^class:World^;)I</replaceMethod>
			<replaceMethod code="{
				java.io.File basesave = getWorldBaseSaveLocation($1);
				String innerSave = $1.^field:World/provider^.getSaveFolder();
				if (innerSave != null) {
					return new java.io.File(basesave, innerSave);
				}

				return basesave;
			}">getWorldSaveLocation(L^class:World^;I)Ljava.io.File;
			</replaceMethod>
		</class>
	</chickenChunks>
	<wirelessRedstone>
		<class id="codechicken.wirelessredstone.core.RedstoneEther">
			<replaceInitializer field="playerJammedMap" class="me.nallar.collections.CHashMap"/>
			<final field="playerJammedMap"/>
		</class>
		<class id="codechicken.wirelessredstone.core.RedstoneEtherServer">
			<synchronize>tick</synchronize>
		</class>
		<class id="codechicken.wirelessredstone.core.RedstoneEtherFrequency">
			<replaceMethodCall index="0" code="{}" method="println">updateReceiver</replaceMethodCall>
		</class>
	</wirelessRedstone>
	<myTown>
		<class id="ee.lutsu.alpha.mc.mytown.event.ProtectionEvents">
			<synchronize>tickStart</synchronize>
		</class>
		<class id="ee.lutsu.alpha.mc.mytown.MyTownDatasource">
			<synchronize field="$1.intern()">getOrMakeResident(Ljava.lang.String;)Lee.lutsu.alpha.mc.mytown.entities.Resident;</synchronize>
		</class>
	</myTown>
	<soulShards>
		<class id="com.shadwdrgn.soulshards.CommonProxy">
			<replaceMethodCall index="0" code="{}" method="println">processShard</replaceMethodCall>
		</class>
	</soulShards>
	<extraBiomesXL>
		<class id="extrabiomes.blocks.BlockAutumnLeaves$BlockType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize/>
		</class>
		<class id="extrabiomes.blocks.BlockGreenLeaves$BlockType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize/>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenLegendOak$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenFirTreeHuge$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenFirTree$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenAutumnTree$AutumnTreeType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenAcacia$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenRedwood$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
	</extraBiomesXL>
	<portalGun>
		<class id="portalgun.common.core.TickHandlerServer">
			<synchronize field="$1.e">worldTick</synchronize>
			<replaceInitializer field="grabMap" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="portals" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="moonPortals" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="potatosProgression" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="lastSeenEntity" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="hasFallen" class="me.nallar.collections.CHashMap"/>
		</class>
		<class id="portalgun.common.core.ChunkLoadHandler">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
		</class>
	</portalGun>
	<graviGun>
		<class id="gravigun.common.core.TickHandlerServer">
			<synchronize field="$1.i">worldTick</synchronize>
			<replaceInitializer field="grabMap" class="java.util.concurrent.ConcurrentHashMap"/>
			<replaceInitializer field="tossedEntities" class="java.util.concurrent.ConcurrentHashMap"/>
			<replaceInitializer field="tosser" class="java.util.concurrent.ConcurrentHashMap"/>
			<replaceInitializer field="chargedThrow" class="java.util.concurrent.ConcurrentHashMap"/>
		</class>
	</graviGun>
	<twilightForest>
		<class id="twilightforest.entity.HydraHeadContainer">
			<insertBefore code="{
				if ($1 != null &amp;&amp; $1.^field:Entity/boundingBox^ == null) {
					return;
				}
			}">faceEntity,setTargetEntity
			</insertBefore>
		</class>
		<class id="twilightforest.TFFeatureCache">
			<replaceInitializer field="cache" class="me.nallar.collections.SynchronizedList"/>
			<synchronize field="cache">save</synchronize>
			<insertAfter code="{
				if (!(cache instanceof me.nallar.collections.SynchronizedList)) {
					cache = new me.nallar.collections.SynchronizedList(cache);
				}
			}">load
			</insertAfter>
		</class>
		<class id="twilightforest.TFEventListener">
			<synchronize>worldSave</synchronize>
		</class>
		<class id="twilightforest.block.BlockTFMagicLogSpecial">
			<!-- Spams logs, slow -->
			<disable>doSortingTreeEffect</disable>
		</class>
		<class id="twilightforest.biomes.TFBiomeDecorator">
			<synchronize>^method:BiomeDecorator/decorate^</synchronize>
		</class>
	</twilightForest>
	<bukkitForge>
		<class id="org.bukkit.plugin.SimplePluginManager">
			<replaceMethod code="{ fireEvent($$); }">callEvent</replaceMethod>
		</class>
	</bukkitForge>
	<additionalPipes>
		<class id="buildcraft.additionalpipes.pipes.PipePowerTeleport">
			<synchronize>receiveEnergy,requestEnergy</synchronize>
		</class>
		<class id="buildcraft.additionalpipes.pipes.TeleportManager">
			<synchronize>getConnectedPipes</synchronize>
		</class>
	</additionalPipes>
	<MFFS>
		<class id="chb.mods.mffs.network.server.ForceFieldServerUpdatehandler">
			<synchronize>tickEnd</synchronize>
		</class>
		<class id="chb.mods.mffs.common.item.ItemCardPowerLink">
			<synchronize/>
		</class>
		<class id="chb.mods.mffs.common.ModularForceFieldSystem$MFFSChunkloadCallback">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
		</class>
		<class id="chb.mods.mffs.common.Linkgrid$Worldlinknet">
			<replaceInitializer field="FieldFusion" class="java.util.concurrent.ConcurrentHashMap"/>
			<replaceInitializer field="Jammer" class="java.util.concurrent.ConcurrentHashMap"/>
		</class>
		<class id="chb.mods.mffs.common.tileentity.TileEntityProjector">
			<synchronize>calculateField(Z)Z</synchronize>
		</class>
	</MFFS>
	<thaumcraft>
		<class id="thaumcraft.api.ObjectTags">
			<replaceInitializer field="tags" class="me.nallar.collections.CHashMap"/>
		</class>
		<class id="thaumcraft.common.AuraManager">
			<synchronize>registerAuraNode</synchronize>
		</class>
		<class id="thaumcraft.common.AuraWorldTicker">
			<synchronize field="((^class:WorldServer^)$2[0]).auraLock">tickEnd</synchronize>
		</class>
		<class id="thaumcraft.common.EventHandler">
			<synchronize field="$1.world.auraLock">chunkLoad</synchronize>
		</class>
		<class id="thaumcraft.common.blocks.TileCrystalCapacitor">
			<replaceFieldUsage field="count" writeCode="{ }" readCode="{ $_ = null; }">^all^</replaceFieldUsage>
			<removeField field="count"/>
			<insertAfter code="interval = new Random().nextInt(300);"/>
			<replaceMethod code="{
				^class:World^ world = this.^field:TileEntity/worldObj^;
				if (!world.onClient() &amp;&amp; interval++ % 300 == 0) {
					ArrayList e = thaumcraft.common.AuraManager.getAurasWithin(world, ^field:TileEntity/xCoord^ + 0.5, ^field:TileEntity/yCoord^ + 0.5, ^field:TileEntity/zCoord^ + 0.5);
					if(e.size() == 0) {
					   return;
					}

					Iterator i$ = e.iterator();

					while(i$.hasNext()) {
					   Integer key = (Integer)i$.next();
					   thaumcraft.api.AuraNode nd = thaumcraft.common.AuraManager.getNode(key.intValue());
					   if(nd != null) {
					      if(nd.level &gt; nd.baseLevel &amp;&amp; this.storedVis &lt; this.maxVis) {
					         thaumcraft.common.AuraManager.queueNodeChanges(nd.key, -1, 0, false, null, 0.0F, 0.0F, 0.0F);
					         ++this.storedVis;
					         sendTile();
					         break;
					      }

					      if(nd.level &lt; nd.baseLevel &amp;&amp; this.storedVis &gt; 0) {
					         thaumcraft.common.AuraManager.queueNodeChanges(nd.key, 1, 0, false, null, 0.0F, 0.0F, 0.0F);
					         --this.storedVis;
					         sendTile();
					         break;
					      }
					   }
					}
				}
			}">^method:TileEntity/updateEntity^
			</replaceMethod>
		</class>
		<class id="thaumcraft.common.blocks.TileMarker">
			<replaceInitializer field="markers" class="me.nallar.collections.CHashMap">^static^</replaceInitializer>
			<replaceInitializer field="markedForDeletion" class="me.nallar.collections.ArrayListReplaceIterateTempListClear">^static^</replaceInitializer>
		</class>
		<class id="thaumcraft.common.blocks.TileSensor">
			<replaceMethod code="((ArrayList) noteBlockEvents.get($1)).addAll($1.getNoteBlockEvents());">getNoteBlockEvents</replaceMethod>
		</class>
	</thaumcraft>
	<universalElectricity>
		<class id="universalelectricity.core.electricity.Electricity">
			<newField field="cleanNetworkCount" class="int" code="0"/>
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<replaceInitializer field="electricityNetworks" class="me.nallar.collections.LockArrayList"/>
			<insertAfter code="((me.nallar.collections.LockArrayList)electricityNetworks).lock = writeLock;"/>
			<lock field="readLock">unregister,cleanUpNetworks,resetConductors</lock>
			<synchronize>mergeConnection,splitConnection,cleanUpNetworks</synchronize>
			<insertBefore code="if (cleanNetworkCount++ % 15 != 0) { return; }">cleanUpNetworks</insertBefore>
		</class>
		<class id="universalelectricity.core.electricity.ElectricityConnections">
			<replaceInitializer field="connectors" class="me.nallar.collections.CHashMap"/>
		</class>
		<class id="universalelectricity.core.electricity.ElectricityNetwork">
			<replaceMethodCall code="$_ = $0.getTEWithoutLoad($$);" method="^class:World^.^method:World/getBlockTileEntity^">getProduced,getRequestWithoutReduction</replaceMethodCall>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="none"/>
			<replaceMethod code="{
				me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock readWriteLock = new me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock();
				readLock = readWriteLock.readLock();
				consumers = new me.nallar.collections.CHashMap();
				producers = new me.nallar.collections.CHashMap();
				conductors = new me.nallar.collections.LockArrayList();
				((me.nallar.collections.LockArrayList)conductors).lock = readWriteLock.writeLock();
				this.addConductor($1);
			}"/>
			<lock field="readLock">addConductor,cleanConductors,setNetwork,resetConductors,onOverCharge,getTotalResistance,refreshConductors</lock>
		</class>
	</universalElectricity>
	<appliedEnergistics>
		<class id="appeng.me.CellInventory">
			<synchronize>^all^</synchronize>
		</class>
		<class id="appeng.me.Platform">
			<synchronize>getSharedTagCompound</synchronize>
			<synchronize field="$2">addStackToList</synchronize>
			<synchronize field="$1">addStackToList</synchronize>
		</class>
		<class id="appeng.me.tile.TileController">
			<replaceInitializer field="WaitingQueue" class="me.nallar.collections.ConcurrentLinkedQueueList"/>
			<replaceInitializer field="CraftingQueue" class="me.nallar.collections.ConcurrentLinkedQueueList"/>
			<synchronize>getCellArray,^method:TileEntity/updateEntity^,advanceCraftingCursor,resetWaitingQueue</synchronize>
		</class>
		<class id="appeng.me.tile.TileDrive">
			<synchronize>getCellArray,resetCache</synchronize>
		</class>
		<class id="appeng.me.tile.TileChest">
			<synchronize>getCellArray,resetCache</synchronize>
		</class>
		<class id="appeng.me.tile.TileStorageBus">
			<replaceNew oldClass="java.util.ArrayList" newClass="me.nallar.collections.ArrayListTempSetNoClear">^method:TileEntity/updateEntity^</replaceNew>
			<replaceMethodCall method="iterator" index="0" code="$_ = ((me.nallar.collections.ArrayListTempSetNoClear) $0).startIteration();">^method:TileEntity/updateEntity^</replaceMethodCall>
			<replaceMethodCall method="signalInput" code="{
				$_ = $0.signalInput($$);
				((me.nallar.collections.ArrayListTempSetNoClear) this.oldList).done();
			}">^method:TileEntity/updateEntity^
			</replaceMethodCall>
			<synchronize>getCellArray,getSharedTagCompound,signalInput</synchronize>
		</class>
		<class id="appeng.me.MEInventoryArray">
			<synchronize>^all^</synchronize>
		</class>
		<class id="appeng.common.MEGridEvents">
			<replaceInitializer field="requests" class="me.nallar.collections.ConcurrentQueueList">^static^</replaceInitializer>
		</class>
	</appliedEnergistics>
	<xyCraft>
		<class id="soaryn.xycraft.machines.block.XyCraftWorldExtension">
			<replaceInitializer field="multiBlocks" class="me.nallar.collections.CHashMap"/>
			<replaceInitializer field="deferredLoadSet" class="me.nallar.collections.HashSetReplaceIterateTempListNoClear"/>
			<synchronize>defer,remMultiBlock</synchronize>
			<replaceFieldUsage field="useTemp" writeCode="$1 = false;">updateDeffered</replaceFieldUsage>
			<insertAfter code="deferredLoadSet.clear();">updateDeffered</insertAfter>
			<replaceMethod code="synchronized (tempList) { return this.nextMultiBlockID++; }">getNextMultiBlockID</replaceMethod>
		</class>
	</xyCraft>
	<denLib>
		<class id="denoflionsx.denLib">
			<replaceMethod code="return $1;">Hash</replaceMethod>
		</class>
	</denLib>
	<icbm>
		<class id="icbm.api.RadarRegistry">
			<replaceMethod code="detectableEntities.remove($1);">unregister(L^class:Entity^;)V</replaceMethod>
			<replaceMethod code="detectableTileEntities.remove($1);">unregister(L^class:TileEntity^;)V</replaceMethod>
			<replaceMethodCall code="$_ = $0.getTEWithoutLoad($$);" method="^class:World^.^method:World/getBlockTileEntity^">cleanUpArray</replaceMethodCall>
			<synchronize>
				cleanUpArray,getEntitiesWithinRadius,getTileEntitiesInArea,unregister(L^class:Entity^;)V,unregister(L^class:TileEntity^;)V,register(L^class:Entity^;)V,register(L^class:TileEntity^;)V
			</synchronize>
			<insertBefore code="if (!Thread.holdsLock(icbm.api.RadarRegistry.class)) { throw new UnsupportedOperationException(&quot;Not threadsafe.&quot;); }">getEntities,getTileEntities</insertBefore>
		</class>
	</icbm>
	<forestry>
		<class id="forestry.apiculture.gadgets.TileAlvearyPlain">
			<replaceInitializer field="modifiers" code="$_ = java.util.Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap());"/>
			<replaceInitializer field="eventHandlers" code="$_ = java.util.Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap());"/>
		</class>
	</forestry>
	<railCraft>
		<class id="railcraft.common.util.misc.ChunkManager">
			<replaceMethodCall newMethod="getTEWithLoad" method="^class:World^.^method:World/getBlockTileEntity^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
			<replaceMethodCall newMethod="getBlockIdWithLoad" method="^class:World^.^method:World/getBlockId^">
				ticketsLoaded(Ljava.util.List;L^class:World^;)V,ticketsLoaded(Ljava.util.List;L^class:World^;I)Ljava.util.List;
			</replaceMethodCall>
		</class>
	</railCraft>
	<seasons>
		<class id="WeatherPony.Seasons.Seasons_WorldData">
			<insertAfter code="worldsettings = new java.util.concurrent.ConcurrentHashMap();"/>
		</class>
	</seasons>
	<customOreGen>
		<class id="CustomOreGen.Server.ServerState">
			<replaceMethod code="{ return $1.isChunkSavedPopulated($2, $3); }">isChunkSavedPopulated</replaceMethod>
		</class>
	</customOreGen>
	<enderStorage>
		<class id="codechicken.enderstorage.api.EnderStorageManager">
			<insertAfter code="dirtyStorage = new me.nallar.collections.LinkedListReplaceIterateTempListClear();"/>
		</class>
	</enderStorage>
	<millenaire>
		<class id="org.millenaire.common.forge.Mill">
			<replaceInitializer field="serverWorlds" class="me.nallar.collections.CopyOnWriteVector"/>
		</class>
		<class id="org.millenaire.common.MillVillager">
			<replaceMethodCall method="error" code="{ }">registerInGlobalList</replaceMethodCall>
		</class>
		<class id="org.millenaire.common.MillWorld">
			<replaceMethod code="{ return (org.millenaire.common.Building) this.buildings.get($1);	}">getBuilding</replaceMethod>
		</class>
		<class id="org.millenaire.common.Point">
			<replaceMethod code="{
				return ((int) x) | (((int) y) &lt;&lt; 12) | (((int) z) &lt;&lt; 20);
			}">hashCode
			</replaceMethod>
		</class>
	</millenaire>
	<stevesCarts>
		<class id="vswe.stevescarts.CommonProxy">
			<replaceMethod code="{
				^class:Entity^ entity = $2.getEntity($1);
				if (entity instanceof vswe.stevescarts.Carts.entMCBase) {
					return (vswe.stevescarts.Carts.entMCBase) entity;
				}
				return null;
			}">getCart
			</replaceMethod>
		</class>
	</stevesCarts>
</mods>
