<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<mods>
	<minecraftCommon>
		<class id="net.minecraft.world.SpawnerAnimals">
			<addAll fromClass="me.nallar.patched.PatchSpawnerAnimals"/>
			<profile>findChunksForSpawning</profile>
		</class>
		<class id="net.minecraft.pathfinding.Path">
			<newInitializer field="pathPoints" class="net.minecraft.pathfinding.PathPoint" arraySize="128"/>
		</class>
		<class id="net.minecraft.server.MinecraftServer">
			<addAll fromClass="me.nallar.patched.server.PatchMinecraftServer"/>
			<public field="mcServer"/>
		</class>
		<class id="net.minecraft.server.MinecraftServer" env="mcpc">
			<replaceMethod code="org.bukkit.craftbukkit.v1_4_R1.util.WatchdogThread.tick();">spigotTick</replaceMethod>
			<replaceMethod code="{
					this.server.getScheduler().mainThreadHeartbeat(this.w);

					while (!processQueue.isEmpty()) {
							((Runnable) processQueue.remove()).run();
					}

					org.bukkit.craftbukkit.v1_4_R1.chunkio.ChunkIOExecutor.tick();
        }">spigotTLETick
			</replaceMethod>
		</class>
		<class id="net.minecraft.server.MinecraftServer" env="forge">
			<addAll fromClass="me.nallar.patched.server.PatchMinecraftServerForge"/>
		</class>
		<class id="net.minecraft.profiler.Profiler">
			<addAll fromClass="me.nallar.patched.PatchProfiler"/>
		</class>
		<class id="net.minecraft.network.NetServerHandler">
			<addAll fromClass="me.nallar.patched.network.PatchNetServerHandler"/>
			<replaceMethodCall method="warning"
												 code="{ javassist.is.faulty.Redirects.notifyAdmins($1); }"
							>handleFlying
			</replaceMethodCall>
		</class>
		<class id="net.minecraft.network.packet.Packet10Flying">
			<addAll fromClass="me.nallar.patched.network.PatchPacket10Flying"/>
		</class>
		<class id="net.minecraft.network.packet.Packet14BlockDig">
			<addAll fromClass="me.nallar.patched.network.PatchPacketAsync"/>
		</class>
		<class id="net.minecraft.network.packet.Packet51MapChunk">
			<volatile field="chunkData"/>
			<addAll fromClass="me.nallar.patched.network.PatchPacket51MapChunk"/>
			<threadLocal field="temp" type="byte[]" threadLocalField="javassist.is.faulty.ThreadLocals.mapChunkTempByteArray">getMapChunkData</threadLocal>
		</class>
		<class id="net.minecraft.network.packet.Packet56MapChunks">
			<volatile field="chunkDataBuffer"/>
		</class>
		<class id="net.minecraft.network.packet.Packet254ServerPing">
			<addAll fromClass="me.nallar.patched.network.PatchPacketAsync"/>
		</class>
		<class id="net.minecraft.network.NetworkListenThread">
			<synchronize>addPlayer,networkTick</synchronize>
			<profile>networkTick</profile>
			<replaceMethodCall code="{ $_ = null; }" method="log" index="1">networkTick</replaceMethodCall>
		</class>
		<class id="net.minecraft.network.TcpWriterThread">
			<ignoreExceptions type="java.net.SocketException">run</ignoreExceptions>
		</class>
		<class id="net.minecraft.world.World">
			<addAll fromClass="me.nallar.patched.world.PatchWorld"/>
			<profile>updateEntities</profile>
			<profile>setActivePlayerChunksAndCheckLight</profile>
			<public>releaseEntitySkin</public>
			<final field="worldAccesses"/>
			<final field="provider"/>
			<final field="theProfiler"/>
			<public field="ambientTickCountdown"/>
			<replaceInitializer field="playerEntities" code="new java.util.concurrent.CopyOnWriteArrayList();"/>
		</class>
		<class id="net.minecraft.world.NextTickListEntry">
			<newField static="" field="nextEntryID_" class="java.util.concurrent.atomic.AtomicLong"/>
			<insertAfter field="tickEntryID" code="this.$field = this.nextEntryID_.getAndIncrement();"/>
		</class>
		<class id="net.minecraft.world.WorldServer">
			<synchronize>addBlockEvent,sendAndApplyBlockEvents</synchronize>
			<addAll fromClass="me.nallar.patched.world.PatchWorldServer"/>
			<profile>tickBlocksAndAmbiance</profile>
			<profile>tick</profile>
			<insertSuper>initialize</insertSuper>
		</class>
		<class id="net.minecraft.world.biome.WorldChunkManager">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">getModdedBiomeGenerators</synchronize>
		</class>
		<class id="net.minecraft.world.biome.BiomeCache">
			<synchronize>getBiomeCacheBlock,cleanupCache</synchronize>
		</class>
		<class id="net.minecraft.world.gen.structure.MapGenStructure">
			<replaceInitializer field="structureMap" code="new java.util.concurrent.ConcurrentHashMap();"/>
		</class>
		<class id="net.minecraft.world.gen.ChunkProviderServer">
			<replace class="me.nallar.patched.storage.ThreadedChunkProvider"/>
		</class>
		<class id="net.minecraft.world.gen.ChunkProviderServer" env="mcpc">
			<changeFieldType field="chunksToUnload" type="org.bukkit.craftbukkit.v1_4_R1.util.LongHashSet" remove="true"/>
			<insertAfter field="chunksToUnload" code="$field = new org.bukkit.craftbukkit.v1_4_R1.util.LongHashSet();"/>
		</class>
		<class id="net.minecraft.world.chunk.storage.RegionFileCache" env="forge">
			<replaceMethod code="throw new UnsupportedOperationException();">createOrLoadRegionFile</replaceMethod>
		</class>
		<class id="net.minecraft.world.chunk.storage.AnvilChunkLoader" env="forge">
			<addAll fromClass="me.nallar.patched.storage.PatchAnvilChunkLoader"/>
		</class>
		<class id="net.minecraft.world.chunk.Chunk">
			<!-- The entity list could be accessed from multiple threads, as usual causes problems during iteration -->
			<addAll fromClass="me.nallar.patched.storage.PatchChunk"/>
			<final field="xPosition"/>
			<final field="zPosition"/>
			<final field="entityLists"/>
			<final field="worldObj"/>
			<lock field="entityListWriteLock">onChunkLoad,onChunkUnload,removeEntityAtIndex,addEntity</lock>
			<lock field="entityListReadLock">getEntitiesWithinAABBForEntity,getEntitiesOfTypeWithinAAAB</lock>
		</class>
		<class id="net.minecraft.util.Vec3Pool">
			<!-- This prevents entities in multiple threads using the same Vec3 for collisions. -->
			<synchronize>getVecFromPool</synchronize>
		</class>
		<class id="net.minecraft.util.Vec3Pool" env="mcpc">
			<synchronize>getVecFromPool,release,clear</synchronize>
		</class>
		<class id="net.minecraft.util.AxisAlignedBB">
			<!-- Improves performance -->
			<replaceMethod fromClass="me.nallar.patched.PatchAxisAlignedBB">intersectsWith</replaceMethod>
		</class>
		<class id="net.minecraft.util.LongHashMap">
			<replace class="me.nallar.patched.collection.LongHashMap"/>
		</class>
		<class id="net.minecraft.util.IntHashMap">
			<replace class="me.nallar.patched.collection.IntHashMap"/>
		</class>
		<class id="net.minecraft.entity.player.EntityPlayerMP">
			<synchronize field="loadedChunks">onUpdate</synchronize>
			<addAll fromClass="me.nallar.patched.entity.PatchEntityPlayerMP"/>
			<!-- Concurrent access during iteration = boom -->
			<replaceInitializer field="destroyedItemsNetCache" code="new me.nallar.tickthreading.collections.ConcurrentLinkedQueueList();"/>
		</class>
		<class id="net.minecraft.entity.Entity">
			<addAll fromClass="me.nallar.patched.entity.PatchEntity"/>
		</class>
		<class id="net.minecraft.nbt.NBTTagCompound">
			<replaceInitializer field="tagMap" code="new java.util.concurrent.ConcurrentHashMap();"/>
			<final field="tagMap"/>
		</class>
		<class id="net.minecraft.entity.Entity">
			<final field="rand"/>
			<newField static="" field="nextEntityID_" class="java.util.concurrent.atomic.AtomicInteger"/>
			<insertAfter field="entityId" code="this.$field = this.nextEntityID_.getAndIncrement();"/>
			<insertBefore code="if ($1 == 0 &amp;&amp; $2 == 0 &amp;&amp; $3 == 0) { return; }">moveEntity</insertBefore>
		</class>
		<class id="net.minecraft.entity.EntityLiving">
			<addAll fromClass="me.nallar.patched.entity.PatchEntityLiving"/>
		</class>
		<class id="net.minecraft.entity.item.EntityItem">
			<addAll fromClass="me.nallar.patched.entity.PatchEntityItem"/>
			<insertSuper>onUpdate</insertSuper>
		</class>
		<class id="net.minecraft.tileentity.TileEntity">
			<addMethod return="java.lang.String"
								 name="toString"
								 code="return super.toString() + &quot; x,y,z: &quot; + l + &quot;, &quot; + m + &quot;, &quot; + n;"/>
			<addAll fromClass="me.nallar.patched.PatchTileEntity"/>
		</class>
		<class id="net.minecraft.entity.EntityTracker">
			<!-- Yet more comodification exceptions -->
			<addAll fromClass="me.nallar.patched.entity.PatchEntityTracker"/>
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">addEntityToTracker(Lnet/minecraft/entity/Entity;)V,addEntityToTracker(Lnet/minecraft/entity/Entity;IIZ)V,removeEntityFromAllTrackingPlayers</lock>
			<lock field="readLock">updateTrackedEntities,removeAllTrackingPlayers,func_85172_a</lock>
		</class>
		<class id="net.minecraft.village.Village">
			<addAll fromClass="me.nallar.patched.PatchVillage"/>
		</class>
		<class id="net.minecraft.village.VillageCollection">
			<addAll fromClass="me.nallar.patched.collection.PatchVillageCollection"/>
			<!-- Literally the most useless collection. Locking instead of voiding in case it ever does something useful in future -->
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="writeLock">addVillagerPosition</lock>
			<lock field="readLock">findNearestVillage,func_82566_a</lock>
		</class>
		<class id="net.minecraft.server.dedicated.DedicatedServerSleepThread">
			<disable>run</disable>
		</class>
		<class id="net.minecraft.server.management.ServerConfigurationManager">
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="playersUpdateLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="playerUpdateLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<lock field="playerUpdateLock">createPlayerForUser,sendPacketToAllPlayers,sendPlayerInfoToAllPlayers</lock>
			<lock field="playerUpdateLock">sendPacketToAllPlayersInDimension,getPlayerListAsString,getAllUsernames,getPlayerForUsername,findPlayers,sendToAllNearExcept</lock>
			<lock field="playerUpdateLock">saveAllPlayerData,getPlayerList</lock>
			<lockMethodCall method="add" field="playersUpdateLock">playerLoggedOut,playerLoggedIn,respawnPlayer</lockMethodCall>
			<lockMethodCall method="remove" field="playersUpdateLock">playerLoggedOut,playerLoggedIn,respawnPlayer</lockMethodCall>
			<synchronize field="$1.loadedChunks">respawnPlayer</synchronize>
			<synchronize field="$1.loadedChunks">transferPlayerToDimension(Lnet.minecraft.entity.player.EntityPlayerMP;ILnet.minecraft.world.Teleporter;)V</synchronize>
			<synchronize field="$2.loadedChunks">initializeConnectionToPlayer</synchronize>
		</class>
		<class id="net.minecraft.server.management.ServerConfigurationManager" env="forge">
			<addAll fromClass="me.nallar.patched.server.PatchServerConfigurationManager"/>
		</class>
		<class id="net.minecraft.server.management.PlayerManager">
			<newField field="readWriteLock" class="java.util.concurrent.locks.ReentrantReadWriteLock"/>
			<newField field="playersUpdateLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="playerUpdateLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<addAll fromClass="me.nallar.patched.world.tracking.PatchPlayerManager"/>
		</class>
		<class id="net.minecraft.server.management.PlayerManager" env="forge">
			<addAll fromClass="me.nallar.patched.world.tracking.PatchPlayerManagerForge"/>
		</class>
		<class id="net.minecraft.server.management.PlayerManager" env="mcpc">
			<lock field="playersUpdateLock">updatePlayerInstances</lock>
		</class>
		<class id="net.minecraft.server.management.PlayerManager">
			<synchronize field="$1.loadedChunks">addPlayer,removePlayer,filterChunkLoadQueue</synchronize>
			<synchronize field="$1.loadedChunks">updateMountedMovingPlayer</synchronize>
			<synchronize>addPlayer,removePlayer</synchronize>
			<profile>updatePlayerInstances</profile>
		</class>
		<class id="net.minecraft.server.management.PlayerInstance">
			<addAll fromClass="me.nallar.patched.world.tracking.PatchPlayerInstance"/>
			<insertBefore code="this.sendTiles();">sendChunkUpdate</insertBefore>
		</class>
		<class id="net.minecraft.server.management.PlayerInstance" env="forge">
			<addAll fromClass="me.nallar.patched.world.tracking.PatchPlayerInstanceForge"/>
			<lock field="myManager.playerUpdateLock">flagChunkForUpdate,sendChunkUpdate</lock>
			<replaceMethodCall index="1" code="{ $_ = null; }"/>
		</class>
		<class id="net.minecraft.server.management.PlayerInstance">
			<synchronize field="$1.loadedChunks">addPlayerToChunkWatchingList,sendThisChunkToPlayer</synchronize>
		</class>
		<class id="net.minecraft.world.ChunkCoordIntPair">
			<addAll fromClass="me.nallar.patched.storage.PatchChunkCoordIntPair"/>
			<public field="chunkXPos"/>
			<public field="chunkZPos"/>
			<noFinal field="chunkXPos"/>
			<noFinal field="chunkZPos"/>
		</class>
		<class id="net.minecraft.crash.CrashReport">
			<addAll fromClass="me.nallar.patched.server.PatchCrashReport"/>
		</class>
		<class id="net.minecraft.block.BlockRedstoneTorch">
			<addAll fromClass="me.nallar.patched.block.PatchBlockRedstoneTorch"/>
		</class>
		<class id="net.minecraft.block.BlockRedstoneWire">
			<synchronize>calculateCurrentChanges,updateAndPropagateCurrentStrength</synchronize>
		</class>
		<class id="net.minecraft.network.TcpConnection">
			<addAll fromClass="me.nallar.patched.network.PatchTcpConnection"/>
		</class>
		<class id="net.minecraft.network.TcpReaderThread">
			<replace class="me.nallar.patched.network.PatchTcpReaderThread"/>
		</class>
		<class id="net.minecraft.entity.ai.EntityAITasks">
			<synchronize>addTask,func_85156_a,onUpdateTasks,func_75775_b</synchronize>
		</class>
	</minecraftCommon>
	<bukkit>
		<class id="org.bukkit.craftbukkit.v1_4_R1.CraftWorld">
			<replaceMethod
							code=" {
							Object[] chunks = world.getChunks();
							org.bukkit.Chunk[] craftChunks = new org.bukkit.Chunk[chunks.length];
							for (int i = 0; i &lt; craftChunks.length; i++) {
								craftChunks[i] = ((zz) chunks[i]).bukkitChunk;
							}
							return craftChunks;
							} "
							>getLoadedChunks</replaceMethod>
		</class>
	</bukkit>
	<forge>
		<class id="net.minecraftforge.common.Configuration">
			<addAll fromClass="me.nallar.patched.forge.PatchConfiguration"/>
		</class>
		<class id="net.minecraftforge.common.ConfigCategory">
			<addAll fromClass="me.nallar.patched.forge.PatchConfigCategory"/>
		</class>
		<class id="net.minecraftforge.event.Event">
			<addAll fromClass="me.nallar.patched.forge.PatchEvent"/>
		</class>
		<class id="net.minecraftforge.common.DimensionManager">
			<addAll fromClass="me.nallar.patched.forge.PatchDimensionManager"/>
			<synchronize field="unloadQueue">unloadWorld</synchronize>
		</class>
		<class id="net.minecraftforge.common.ForgeChunkManager">
			<addAll fromClass="me.nallar.patched.forge.PatchForgeChunkManager"/>
		</class>
	</forge>
	<forgeModLoader>
		<class id="cpw.mods.fml.relauncher.FMLLogFormatter">
			<replace class="me.nallar.tickthreading.LogFormatter"/>
		</class>
		<class id="cpw.mods.fml.common.event.FMLInterModComms$IMCMessage">
			<addAll fromClass="me.nallar.patched.forge.PatchIMCMessage"/>
		</class>
		<class id="cpw.mods.fml.common.Loader">
			<addAll fromClass="me.nallar.patched.forge.PatchLoader"/>
		</class>
		<class id="cpw.mods.fml.common.Loader$ModIdComparator">
			<public/>
		</class>
		<class id="cpw.mods.fml.common.asm.FMLSanityChecker">
			<replaceMethodCall code="{ $_ = null; }" method="severe">call</replaceMethodCall>
		</class>
		<class id="cpw.mods.fml.common.FMLModContainer">
			<replaceMethodCall index="0" code="{ $_ = null; }" method="log">constructMod</replaceMethodCall>
			<replaceFieldUsage field="fingerprintNotPresent" readCode="$_ = false;">constructMod</replaceFieldUsage>
			<replaceFieldUsage field="expectedFingerprint" readCode="$_ = null;">constructMod</replaceFieldUsage>
		</class>
		<class id="cpw.mods.fml.common.registry.BlockTracker">
			<synchronize>getNextBlockId,doReserveId</synchronize>
		</class>
		<class id="cpw.mods.fml.common.FMLCommonHandler">
			<addAll fromClass="me.nallar.patched.forge.PatchFMLCommonHandler"/>
		</class>
		<class id="cpw.mods.fml.relauncher.RelaunchClassLoader">
			<addAll fromClass="me.nallar.patched.forge.PatchRelaunchClassLoader"/>
			<synchronize>findClass</synchronize>
		</class>
		<class id="cpw.mods.fml.common.network.ModListResponsePacket">
			<replaceMethodCall index="2" code="{ $_ = null; }" method="info">execute</replaceMethodCall>
			<replaceMethodCall index="3" code="{ $_ = null; }" method="info">execute</replaceMethodCall>
		</class>
	</forgeModLoader>
	<factorization>
		<class id="factorization.common.TileEntityWrathLamp">
			<threadLocal field="toVisit" type="java.util.HashSet" threadLocalField="javassist.is.faulty.ThreadLocals.factorizationFindLightAirParentToVisit"/>
		</class>
		<class id="factorization.api.Charge">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">update</synchronize>
		</class>
		<class id="factorization.common.TileEntityBarrel">
			<synchronize>a(ILur;)V</synchronize>
		</class>
	</factorization>
	<liteLoader>
		<class id="com.mumfrey.liteloader.core.HookProfiler">
			<!-- LiteLoader makes the profiler not threadsafe - I may look into patching this better in future, but TT isn't really intended for clients -->
			<synchronize>a(Ljava/lang/String;)V,b()V</synchronize>
		</class>
	</liteLoader>
	<buildCraftTransport>
		<class id="buildcraft.transport.TileGenericPipe">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">initialize</synchronize>
			<synchronize field="facadeBlocks">blockCreated,getBlockId,getTile,computeConnections</synchronize>
		</class>
		<class id="buildcraft.transport.PipeTransportItems">
			<!-- TODO: Find a more suitable way of making this concurrent without making performRemoval slow -->
			<replaceInitializer field="travelingEntities" code="new java.util.concurrent.ConcurrentHashMap();"/>
		</class>
		<class id="buildcraft.transport.PipeTransportPower">
			<!-- TODO: Non-static lock, if possible -->
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">updateEntity</synchronize>
		</class>
	</buildCraftTransport>
	<thermalExpansionTransport>
		<class id="thermalexpansion.transport.tileentity.TileConduitEnergy">
			<newField field="tickLock" class="java.lang.Object" static=""/>
			<synchronize field="tickLock">updateGridIfNull</synchronize>
		</class>
		<class id="thermalexpansion.transport.tileentity.TileConduitLiquid">
			<newField field="tickLock" class="java.lang.Object" static=""/>
			<synchronize field="tickLock">updateGridIfNull</synchronize>
		</class>
		<class id="thermalexpansion.transport.GridLiquid">
			<synchronize>transferLiquid,removeNode,removeConduit,setNewGrid,changeMode,increaseTracker,addNode,addConduit</synchronize>
		</class>
		<class id="thermalexpansion.transport.GridEnergy">
			<synchronize>transferEnergy,removeNode,removeConduit,setNewGrid,changeMode,increaseTracker,addNode,addConduit</synchronize>
		</class>
	</thermalExpansionTransport>
	<redPowerCore>
		<class id="com.eloraam.redpower.core.RedPowerLib">
			<threadLocal field="blockUpdates" type="java.util.HashSet" threadLocalField="javassist.is.faulty.ThreadLocals.redPowerBlockUpdateSet"/>
			<threadLocal field="powerSearchTest" type="java.util.HashSet" threadLocalField="javassist.is.faulty.ThreadLocals.redPowerPowerSearchTest"/>
			<threadLocal field="powerSearch" type="java.util.LinkedList" threadLocalField="javassist.is.faulty.ThreadLocals.redPowerPowerSearch"/>
			<!-- Still broken - crashes JVM!
			<threadLocal field="searching" type="boolean" setExpression="java.lang.Boolean.valueOf($1)" threadLocalField="javassist.is.faulty.ThreadLocals.redPowerIsSearching"/>
			-->
		</class>
		<class id="com.eloraam.redpower.core.TileExtended">
			<replaceMethod code="this.sendTile();">updateBlock</replaceMethod>
			<replaceMethod code="this.sendTileWithNotify();">updateBlockChange</replaceMethod>
		</class>
		<class id="com.eloraam.redpower.core.TubeFlow">
			<!-- TODO: Non-static lock -->
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">update,add,onRemove</synchronize>
			<!-- Possibly buggy but fast fix
			<replaceField field="contents" class="me.nallar.tickthreading.collections.ConcurrentLinkedQueueList" type="java.util.List"/>
			-->
		</class>
		<class id="com.eloraam.redpower.core.PipeLib">
			<replaceMethodCall index="0" code="{ $_ = null; }" method="printf">registerForgeFluid</replaceMethodCall>
		</class>
		<class id="com.eloraam.redpower.base.ContainerBag">
			<newMethod
							code="public ur a(int i, int j, int k, qx l) { if (k == 2) { javassist.is.faulty.Redirects.notifyAdmins(String.valueOf(l) + &quot; tried to dupe&quot;); l.a(0); return null; } return super.a(i, j, k, l); }"
							/>
		</class>
	</redPowerCore>
	<industrialCraft>
		<class id="ic2.core.IC2">
			<synchronize>addSingleTickCallback</synchronize>
		</class>
		<class id="ic2.core.EnergyNet">
			<replaceMethodCall method="warning" code="{}">emitEnergyFrom</replaceMethodCall>
			<replaceInitializer field="worldToEnergyNetMap" class="java.util.HashMap"/>
			<replaceInitializer field="energySourceToEnergyPathMap" class="java.util.HashMap"/>
			<replaceInitializer field="entityLivingToShockEnergyMap" class="java.util.HashMap"/>
			<!-- TODO: Add correctly implemented double checked locking -->
			<synchronize field="ic2.core.EnergyNet.class">getForWorld</synchronize>
			<synchronize>addTileEntity,removeTileEntity,emitEnergyFrom,discover</synchronize>
		</class>
	</industrialCraft>
	<gregTech>
		<class id="gregtechmod.GT_Mod">
			<synchronize>readIDSUData,writeIDSUData</synchronize>
		</class>
	</gregTech>
	<chickenChunks>
		<class id="codechicken.chunkloader.ChunkLoaderEventHandler">
			<newField field="staticLock" class="java.lang.Object" static=""/>
			<synchronize field="staticLock">tickEnd,onPlayerLogout,onWorldLoad,onWorldUnload,onChunkForce,onChunkUnForce</synchronize>
		</class>
		<class id="codechicken.chunkloader.PlayerChunkViewerManager">
			<synchronize field="$1.b.g">calculateChunkChanges</synchronize>
		</class>
		<class id="codechicken.chunkloader.ChunkLoaderManager">
			<disable>cleanChunks</disable>
		</class>
		<class id="codechicken.chunkloader.CommandChunkLoaders">
			<synchronize field="codechicken.chunkloader.ChunkLoaderEventHandler.staticLock">handleCommand</synchronize>
		</class>
	</chickenChunks>
	<wirelessRedstone>
		<class id="codechicken.wirelessredstone.core.RedstoneEtherServer">
			<synchronize>tick</synchronize>
		</class>
	</wirelessRedstone>
	<myTown>
		<class id="ee.lutsu.alpha.mc.mytown.event.ProtectionEvents">
			<synchronize>tickStart</synchronize>
		</class>
	</myTown>
	<soulShards>
		<class id="com.shadwdrgn.soulshards.CommonProxy">
			<replaceMethodCall index="0" code="{}" method="println">processShard</replaceMethodCall>
		</class>
	</soulShards>
	<extraBiomesXL>
		<class id="extrabiomes.blocks.BlockAutumnLeaves$BlockType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize/>
		</class>
		<class id="extrabiomes.blocks.BlockGreenLeaves$BlockType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize/>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenLegendOak$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenFirTreeHuge$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenFirTree$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenAutumnTree$AutumnTreeType">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenAcacia$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
		<class id="extrabiomes.module.summa.worldgen.WorldGenRedwood$TreeBlock">
			<insertBefore code="if (loadedCustomBlocks) { return; }">loadCustomBlocks</insertBefore>
			<synchronize>loadCustomBlocks</synchronize>
		</class>
	</extraBiomesXL>
	<portalGun>
		<class id="portalgun.common.core.TickHandlerServer">
			<synchronize field="$1.e">worldTick</synchronize>
		</class>
	</portalGun>
	<twilightForest>
		<class id="twilightforest.TFFeatureCache">
			<synchronize>save</synchronize>
		</class>
		<class id="twilightforest.TFEventListener">
			<synchronize>worldSave</synchronize>
		</class>
		<class id="twilightforest.block.BlockTFMagicLogSpecial">
			<!-- Spams logs, slow -->
			<disable>doSortingTreeEffect</disable>
		</class>
	</twilightForest>
	<bukkitForge>
		<class id="org.bukkit.plugin.SimplePluginManager">
			<replaceMethod code="{ fireEvent($$); }">callEvent</replaceMethod>
		</class>
	</bukkitForge>
	<additionalPipes>
		<class id="buildcraft.additionalpipes.pipes.PipePowerTeleport">
			<synchronize>receiveEnergy,requestEnergy</synchronize>
		</class>
		<class id="buildcraft.additionalpipes.pipes.TeleportManager">
			<synchronize>getConnectedPipes</synchronize>
		</class>
	</additionalPipes>
	<MFFS>
		<class id="chb.mods.mffs.common.item.ItemCardPowerLink">
			<synchronize/>
		</class>
	</MFFS>
	<thaumcraft>
		<class id="thaumcraft.common.AuraManager">
			<synchronize>registerAuraNode</synchronize>
		</class>
		<class id="thaumcraft.common.blocks.TileSensor">
			<synchronize field="$1">getNoteBlockEvents</synchronize>
		</class>
	</thaumcraft>
	<universalElectricity>
		<class id="universalelectricity.core.electricity.Electricity">
			<newField field="readWriteLock" class="me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock"/>
			<newField field="writeLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.writeLock();"/>
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="this.readWriteLock.readLock();"/>
			<insertAfter code="{
				if (electricityNetworks.getClass() == java.util.ArrayList.class) {
					electricityNetworks = new me.nallar.tickthreading.collections.LockArrayList(electricityNetworks);
					((me.nallar.tickthreading.collections.LockArrayList)electricityNetworks).lock = writeLock;
				}
				}"/>
			<lock field="readLock">unregister,cleanUpNetworks,resetConductors</lock>
			<synchronize>mergeConnection,splitConnection,cleanUpNetworks</synchronize>
		</class>
		<class id="universalelectricity.core.electricity.ElectricityConnections">
			<replaceInitializer field="connectors" code="new me.nallar.tickthreading.collections.CHashMap();"/>
		</class>
		<class id="universalelectricity.core.electricity.ElectricityNetwork">
			<newField field="readLock" class="java.util.concurrent.locks.Lock" code="none"/>
			<replaceMethod code="{
				me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock readWriteLock = new me.nallar.tickthreading.util.concurrent.TwoWayReentrantReadWriteLock();
				readLock = readWriteLock.readLock();
				consumers = new me.nallar.tickthreading.collections.CHashMap();
				producers = new me.nallar.tickthreading.collections.CHashMap();
				conductors = new me.nallar.tickthreading.collections.LockArrayList();
				((me.nallar.tickthreading.collections.LockArrayList)conductors).lock = readWriteLock.writeLock();
				this.addConductor($1);
			}"/>
			<lock field="readLock">addConductor,cleanConductors,setNetwork,resetConductors,onOverCharge,getTotalResistance,refreshConductors</lock>
		</class>
	</universalElectricity>
	<appeng>
		<class id="appeng.me.tile.TileController">
			<synchronize>getCellArray</synchronize>
		</class>
	</appeng>
</mods>
